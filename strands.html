<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Too Many Words</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="dictionary.js"></script> <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        :root {
            --background-color: #f0f2f5;
            --card-bg: #FFFFFF;
            --text-color: #333;
            --subtle-text: #666;
            --cell-border: #E0E0E0;
            --cell-bg: #fafafa;
            --selected-bg: #2196F3;
            --opponent-selected-bg: #FFC107;
            --bonus-word-color: #4CAF50;
            --winner-overlay: rgba(76, 175, 80, 0.85);
            --loser-overlay: rgba(244, 67, 54, 0.85);
            --draw-overlay: rgba(158, 158, 158, 0.85);
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Hacker Theme */
        body.theme-hacker {
            --background-color: #0d1117;
            --card-bg: #161b22;
            --text-color: #c9d1d9;
            --subtle-text: #8b949e;
            --cell-border: #30363d;
            --cell-bg: #010409;
            --bonus-word-color: #58a6ff;
        }

        /* Cosmic Theme */
        body.theme-cosmic {
            --background-color: #1a202c;
            --card-bg: #2d3748;
            --text-color: #e2e8f0;
            --subtle-text: #a0aec0;
            --cell-border: #4a5568;
            --cell-bg: #171923;
            --bonus-word-color: #faf089;
        }


        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            transition: background-color 0.3s;
        }

        #game-header { text-align: center; margin-bottom: 2rem; }
        h1 { 
            font-family: 'Fredoka One', cursive;
            font-size: 3rem; 
            color: var(--text-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        #main-status { font-size: 1.2rem; font-weight: 500; color: var(--subtle-text); height: 25px; }
        
        #connection-setup { 
            display: flex; 
            flex-direction: column; 
            gap: 1rem; 
            margin-bottom: 1rem; 
            align-items: center; 
            background-color: var(--card-bg); 
            padding: 2rem; 
            border-radius: 16px; 
            box-shadow: var(--box-shadow);
            width: 100%;
            max-width: 400px;
        }
        .input-group { display: flex; flex-direction: column; gap: 1rem; width: 100%; }
        .input-row { display: flex; gap: 1rem; align-items: center; }
        #connection-setup input[type="text"], #theme-select { 
            padding: 0.75rem; 
            border: 1px solid #ccc; 
            border-radius: 8px; 
            font-size: 1rem;
            flex-grow: 1;
            background-color: var(--background-color);
            color: var(--text-color);
        }
        #connection-setup input[type="color"] {
            -webkit-appearance: none;
            width: 48px;
            height: 48px;
            border: none;
            cursor: pointer;
            background: none;
            padding: 0;
        }
        #connection-setup input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 50%;
            border: 2px solid #ddd;
        }
        #connection-setup input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 50%;
        }

        .button-group { display: flex; gap: 1rem; }
        #connection-setup button { 
            padding: 0.75rem 1.5rem; 
            font-size: 1rem; 
            font-weight: 700; 
            color: white; 
            border: none; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        #connection-setup button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #create-room-btn { background-color: #4CAF50; }
        #join-room-btn { background-color: #03A9F4; }

        #game-area { display: none; flex-direction: column; align-items: center; width: 100%; }
        #game-info { display: flex; justify-content: center; width: 100%; max-width: 900px; margin-bottom: 1rem; font-size: 1.5rem; font-weight: bold; }
        #timer-display { color: #f44336; font-family: 'Fredoka One', cursive; font-size: 2rem; transition: transform 0.2s; }
        #timer-display.shake { animation: shake 0.5s infinite; }

        #game-container { display: flex; justify-content: center; gap: 2rem; width: 100%; max-width: 1200px; align-items: flex-start; }
        
        .player-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .player-name {
            font-family: 'Fredoka One', cursive;
            font-size: 1.5rem;
            padding: 0.5rem 1.5rem;
            border-radius: 20px;
            margin-bottom: 1rem;
            color: white;
            transition: background-color 0.3s;
            box-shadow: var(--box-shadow);
        }

        .player-content-wrapper { display: flex; gap: 1.5rem; width: 100%; justify-content: center; }
        #player-content-1 { flex-direction: row-reverse; }
        #player-content-2 { flex-direction: row; }
        
        .board-container { display: flex; flex-direction: column; align-items: center; position: relative; }

        .point-animation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Fredoka One', cursive;
            font-size: 2rem;
            color: var(--bonus-word-color);
            opacity: 0;
            animation: floatUp 1.5s ease-out;
            pointer-events: none;
        }
        
        .lists-container { display: flex; flex-direction: column; width: 200px; }
        
        .result-overlay { position: absolute; top: 2.5rem; left: 0; right: 0; bottom: 0; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: 'Fredoka One', cursive; font-size: 3rem; border-radius: 12px; z-index: 100; text-shadow: 2px 2px 4px #000; }
        .result-overlay.winner { background: var(--winner-overlay); }
        .result-overlay.loser { background: var(--loser-overlay); }
        .result-overlay.draw { background: var(--draw-overlay); }

        .board { display: grid; grid-template-columns: repeat(10, 1fr); gap: 5px; background-color: var(--card-bg); border-radius: 16px; padding: 10px; aspect-ratio: 10 / 12; width: 100%; max-width: 500px; min-width: 300px; user-select: none; box-shadow: var(--box-shadow); }
        .cell { display: flex; align-items: center; justify-content: center; font-size: 1.2rem; font-weight: 700; background-color: var(--cell-bg); color: var(--text-color); border-radius: 8px; cursor: pointer; transition: background-color 0.1s, transform 0.1s; aspect-ratio: 1 / 1; }
        .cell.selected { background-color: var(--selected-bg) !important; color: white; transform: scale(1.05); animation: pop 0.2s; }
        .cell.opponent-selecting { background-color: var(--opponent-selected-bg) !important; }
        .cell.sparkle::after {
            content: 'âœ¨';
            position: absolute;
            font-size: 1.5rem;
            animation: sparkle 0.8s ease-out;
            opacity: 0;
        }

        .score-display { font-size: 2.5rem; font-weight: bold; margin-top: 1rem; font-family: 'Fredoka One', cursive; color: var(--text-color); }
        
        .words-display-area { margin-top: 1rem; width: 100%; text-align: center; }
        .words-display-area h3 { margin-bottom: 0.5rem; font-size: 1rem; color: var(--subtle-text); font-weight: 500; }
        .found-words-list, .bonus-word-list { list-style: none; padding: 0.5rem; margin: 0; height: 120px; overflow-y: auto; background-color: var(--background-color); border-radius: 8px; border: 1px solid var(--cell-border); }
        .found-words-list li { color: var(--text-color); font-size: 0.9rem; }
        .bonus-word-list li { font-weight: 600; color: var(--bonus-word-color); font-size: 0.9rem; }

        #new-game-btn { margin-top: 1.5rem; padding: 0.8rem 1.5rem; font-size: 1rem; font-weight: 700; color: white; background-color: #673AB7; border: none; border-radius: 8px; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; display: none; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #new-game-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        #new-game-btn:disabled { background-color: #b39ddb; cursor: not-allowed; transform: none; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1.05); }
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -150%) scale(1.5); }
        }
        @keyframes sparkle {
            0% { opacity: 1; transform: scale(0.5); }
            100% { opacity: 0; transform: scale(2); }
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

    </style>
</head>
<body>

    <div id="game-header">
        <h1>Too Many Words</h1>
        <div id="main-status">Enter your name to begin!</div>
    </div>

    <div id="connection-setup">
        <div class="input-group">
            <input type="text" id="player-name-input" placeholder="Your Name">
            <div class="input-row">
                <input type="text" id="room-name-input" placeholder="Room Name">
                <input type="color" id="player-color-input" value="#2196F3">
            </div>
             <select id="theme-select">
                <option value="default">Default Theme</option>
                <option value="hacker">Hacker Theme</option>
                <option value="cosmic">Cosmic Theme</option>
            </select>
        </div>
        <div class="button-group">
            <button id="create-room-btn">Create</button>
            <button id="join-room-btn">Join</button>
        </div>
    </div>

    <div id="game-area">
        <div id="game-info">
            <div id="timer-display">Time: 2:00</div>
        </div>
        <div id="game-container">
            <div class="player-area" id="player1-area">
                <h2 class="player-name" id="name-p1">Player 1</h2>
                <div class="player-content-wrapper" id="player-content-1">
                    <div class="board-container" id="board-container-p1">
                        <div class="board" id="board-p1"></div>
                        <div class="score-display" id="score-p1">Score: 0</div>
                    </div>
                    <div class="lists-container">
                        <div class="words-display-area">
                            <h3>Found Words</h3>
                            <ul class="found-words-list" id="found-words-p1"></ul>
                        </div>
                        <div class="words-display-area">
                            <h3>Bonus Words</h3>
                            <ul class="bonus-word-list" id="bonus-words-p1"></ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="player-area" id="player2-area">
                <h2 class="player-name" id="name-p2">Player 2</h2>
                 <div class="player-content-wrapper" id="player-content-2">
                    <div class="board-container" id="board-container-p2">
                        <div class="board" id="board-p2"></div>
                        <div class="score-display" id="score-p2">Score: 0</div>
                    </div>
                    <div class="lists-container">
                        <div class="words-display-area">
                            <h3>Found Words</h3>
                            <ul class="found-words-list" id="found-words-p2"></ul>
                        </div>
                        <div class="words-display-area">
                            <h3>Bonus Words</h3>
                            <ul class="bonus-word-list" id="bonus-words-p2"></ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <button id="new-game-btn">New Game</button>

    <script>
        const FULL_DICTIONARY = new Set(DICTIONARY_WORDS.map(w => w.toUpperCase()));
        
        const correctSound = new Audio('https://www.niilow.com/corect.mp3');
        const wrongSound = new Audio('https://www.niilow.com/wrong.mp3');
        
        const GRID_SIZE = { rows: 12, cols: 10 };
        const GAME_DURATION = 120;

        let peer, conn, isHost, gameTimer;
        let myPlayer, opponentPlayer;

        const mainStatusEl = document.getElementById('main-status');
        const connectionSetupEl = document.getElementById('connection-setup');
        const playerNameInput = document.getElementById('player-name-input');
        const playerColorInput = document.getElementById('player-color-input');
        const themeSelect = document.getElementById('theme-select');
        const roomNameInput = document.getElementById('room-name-input');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const gameAreaEl = document.getElementById('game-area');
        const newGameBtn = document.getElementById('new-game-btn');
        const timerDisplay = document.getElementById('timer-display');

        themeSelect.addEventListener('change', (e) => {
            document.body.className = `theme-${e.target.value}`;
        });

        function getContrastingTextColor(hexcolor){
            if (hexcolor.startsWith('#')) { hexcolor = hexcolor.slice(1); }
            const r = parseInt(hexcolor.substr(0,2),16);
            const g = parseInt(hexcolor.substr(2,2),16);
            const b = parseInt(hexcolor.substr(4,2),16);
            const yiq = ((r*299)+(g*587)+(b*114))/1000;
            return (yiq >= 128) ? '#111' : '#fff';
        }
        
        class Player {
            constructor(id, name, color, isLocal) {
                this.id = id;
                this.name = name;
                this.color = color;
                this.isLocal = isLocal;
                
                this.boardContainerEl = document.getElementById(`board-container-p${id}`);
                this.boardEl = document.getElementById(`board-p${id}`);
                this.scoreEl = document.getElementById(`score-p${id}`);
                this.nameEl = document.getElementById(`name-p${id}`);
                this.areaEl = document.getElementById(`player${id}-area`);
                this.bonusWordListEl = document.getElementById(`bonus-words-p${id}`);
                this.foundWordsListEl = document.getElementById(`found-words-p${id}`);
                
                this.nameEl.textContent = this.name;
                this.nameEl.style.backgroundColor = this.color;
                this.nameEl.style.color = getContrastingTextColor(this.color);

                if (this.isLocal) {
                    document.documentElement.style.setProperty('--selected-bg', this.color);
                }
                
                this.score = 0;
                this.currentDisplayScore = 0;
                this.foundWords = new Set();
                this.isDragging = false;
                this.selectedCells = [];

                if (this.isLocal) {
                    this.boardEl.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                    this.boardEl.addEventListener('mouseover', (e) => this.handleMouseOver(e));
                    document.addEventListener('mouseup', () => this.handleMouseUp());
                }
            }

            reset() {
                this.score = 0;
                this.updateScore(0, true);
                this.foundWords.clear();
                this.bonusWordListEl.innerHTML = '';
                this.foundWordsListEl.innerHTML = '';
                this.boardEl.classList.remove('disabled');
                const overlay = this.areaEl.querySelector('.result-overlay');
                if (overlay) overlay.remove();
            }

            setupBoard(targetWords, grid) {
                this.targetWords = new Set(targetWords);
                this.grid = grid;
                this.drawBoard();
            }
            
            drawBoard() {
                this.boardEl.innerHTML = '';
                for (let r = 0; r < GRID_SIZE.rows; r++) {
                    for (let c = 0; c < GRID_SIZE.cols; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.r = r;
                        cell.dataset.c = c;
                        cell.textContent = this.grid[r][c];
                        this.boardEl.appendChild(cell);
                    }
                }
            }
            
            updateScore(newScore, immediate = false) {
                this.score = newScore;
                if (immediate) {
                    this.currentDisplayScore = newScore;
                    this.scoreEl.textContent = `Score: ${this.score}`;
                    return;
                }
                
                const tick = () => {
                    if (this.currentDisplayScore < this.score) {
                        this.currentDisplayScore++;
                        this.scoreEl.textContent = `Score: ${this.currentDisplayScore}`;
                        requestAnimationFrame(tick);
                    }
                };
                tick();
            }

            triggerPointAnimation(points, isBonus) {
                if (!this.isLocal) return;
                const pointEl = document.createElement('div');
                pointEl.className = 'point-animation';
                pointEl.textContent = `+${points}`;
                if (isBonus) pointEl.style.color = 'gold';

                this.boardContainerEl.appendChild(pointEl);
                setTimeout(() => pointEl.remove(), 1500);
            }

            triggerSparkleAnimation(cells) {
                 if (!this.isLocal) return;
                 cells.forEach(cell => {
                    cell.classList.add('sparkle');
                    setTimeout(() => cell.classList.remove('sparkle'), 800);
                 });
            }

            addBonusWord(word) {
                if (!this.isLocal) return;
                const li = document.createElement('li');
                li.textContent = word;
                this.bonusWordListEl.appendChild(li);
                this.bonusWordListEl.scrollTop = this.bonusWordListEl.scrollHeight;
            }

            addFoundWord(word) {
                if (!this.isLocal) return;
                const li = document.createElement('li');
                li.textContent = word;
                this.foundWordsListEl.appendChild(li);
                this.foundWordsListEl.scrollTop = this.foundWordsListEl.scrollHeight;
            }

            handleMouseDown(e) {
                if (gameTimer <= 0 || !e.target.classList.contains('cell')) return;
                this.isDragging = true;
                this.clearSelection(); 
                this.addCellToSelection(e.target);
            }

            handleMouseOver(e) {
                if (!this.isDragging || !e.target.classList.contains('cell')) return;
                this.addCellToSelection(e.target);
            }

            handleMouseUp() {
                if (!this.isDragging) return;
                this.isDragging = false;
                this.submitWord();
            }
            
            addCellToSelection(cellEl) {
                if (this.selectedCells.includes(cellEl)) return;
                this.selectedCells.push(cellEl);
                cellEl.classList.add('selected');
                this.sendSelectionUpdate();
            }

            clearSelection() {
                this.selectedCells.forEach(cell => cell.classList.remove('selected'));
                this.selectedCells = [];
                this.sendSelectionUpdate();
            }
            
            sendSelectionUpdate() {
                 if(conn && conn.open) conn.send({ type: 'selection_update', path: this.selectedCells.map(c => ({ r: c.dataset.r, c: c.dataset.c })) });
            }

            submitWord() {
                if (this.selectedCells.length < 4) {
                    if (this.selectedCells.length > 0) wrongSound.play();
                    this.clearSelection();
                    return;
                };

                const selectedCellsCopy = [...this.selectedCells];
                const selectedWord = selectedCellsCopy.map(c => c.textContent).join('');
                
                let foundAnyValidWord = false;
                if (this.validateAndScoreWord(selectedWord, selectedCellsCopy)) foundAnyValidWord = true;
                if (this.validateAndScoreWord(selectedWord.split('').reverse().join(''), selectedCellsCopy.reverse())) foundAnyValidWord = true;
                
                if (foundAnyValidWord) {
                    correctSound.play();
                } else {
                    wrongSound.play();
                }
                
                this.clearSelection();
            }

            validateAndScoreWord(word, cells) {
                const upperWord = word.toUpperCase();
                if (word.length < 4 || word.length > 6 || this.foundWords.has(upperWord) || !FULL_DICTIONARY.has(upperWord)) {
                    return false;
                }

                this.foundWords.add(upperWord);
                this.addFoundWord(word);

                let points = word.length;
                let isBonus = this.targetWords.has(upperWord);

                if (isBonus) {
                    points += 10;
                    this.addBonusWord(upperWord);
                    this.triggerSparkleAnimation(cells);
                }

                this.updateScore(this.score + points);
                this.triggerPointAnimation(points, isBonus);
                conn.send({ type: 'word_found', word: upperWord, newScore: this.score, isBonus });
                return true;
            }
            
            updateOpponentSelection(path) {
                this.boardEl.querySelectorAll('.opponent-selecting').forEach(c => c.classList.remove('opponent-selecting'));
                path.forEach(pos => {
                    const cell = this.boardEl.querySelector(`[data-r='${pos.r}'][data-c='${pos.c}']`);
                    if (cell) cell.classList.add('opponent-selecting');
                });
            }
        }
        
        function initializePeer(host, roomName, playerName, playerColor, theme) {
            isHost = host;
            peer = isHost ? new Peer(roomName) : new Peer();

            peer.on('open', (id) => {
                if (!isHost) connectToHost(roomName, playerName, playerColor, theme);
                else mainStatusEl.textContent = `Room "${roomName}" created. Waiting...`;
            });

            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection(playerName, playerColor, theme);
            });
            peer.on('error', (err) => { mainStatusEl.textContent = `Error: ${err.message}`; });
        }

        function connectToHost(roomName, playerName, playerColor, theme) {
            conn = peer.connect(roomName);
            setupConnection(playerName, playerColor, theme);
        }

        function setupConnection(myName, myColor, myTheme) {
            conn.on('open', () => {
                conn.send({ type: 'player_sync', name: myName, color: myColor, theme: myTheme });
                
                connectionSetupEl.style.display = 'none';
                gameAreaEl.style.display = 'flex';
                newGameBtn.style.display = 'block';
                document.body.className = `theme-${myTheme}`;

                const myPlayerId = isHost ? 1 : 2;
                myPlayer = new Player(myPlayerId, myName, myColor, true);
            });

            conn.on('data', (data) => {
                switch (data.type) {
                    case 'player_sync':
                        const opponentId = isHost ? 2 : 1;
                        opponentPlayer = new Player(opponentId, data.name, data.color, false);
                        
                        if (isHost) {
                            conn.send({ type: 'theme_sync', theme: myTheme });
                        }

                         if (isHost) {
                            newGameBtn.disabled = false;
                            mainStatusEl.textContent = `Connected to ${data.name}! Click 'New Game' to start.`;
                        } else {
                            newGameBtn.disabled = true;
                            mainStatusEl.textContent = `Connected to ${data.name}! Waiting for them to start.`;
                        }
                        break;
                    case 'theme_sync':
                        document.body.className = `theme-${data.theme}`;
                        break;
                    case 'start_game':
                        startNewGame(data.targetWords, data.grid);
                        break;
                    case 'selection_update':
                        if(opponentPlayer) opponentPlayer.updateOpponentSelection(data.path);
                        break;
                    case 'word_found':
                        if(opponentPlayer) {
                            opponentPlayer.updateScore(data.newScore);
                            if (data.isBonus) opponentPlayer.triggerPointAnimation(data.word.length + 10, true);
                            else opponentPlayer.triggerPointAnimation(data.word.length, false);
                        }
                        break;
                }
            });
            
            conn.on('close', () => {
                mainStatusEl.textContent = "Opponent disconnected.";
                if(gameTimer) clearInterval(gameTimer);
            });
        }
        
        function generateNewBoard() {
             const targetWords = [...new Set(DICTIONARY_WORDS.filter(w=>w.length >= 4 && w.length <= 6))].sort(() => 0.5 - Math.random()).slice(0, 10);
            targetWords.sort((a,b) => b.length - a.length);

            let grid = Array(GRID_SIZE.rows).fill(null).map(() => Array(GRID_SIZE.cols).fill(''));
            
            for (const word of targetWords) {
                let placed = false;
                for (let i = 0; i < 200 && !placed; i++) {
                    const dir = Math.floor(Math.random() * 4);
                    const wordToPlace = word.toUpperCase();
                    let r, c, canPlace = true;

                    switch(dir) {
                        case 0:
                           r = Math.floor(Math.random() * GRID_SIZE.rows);
                           c = Math.floor(Math.random() * (GRID_SIZE.cols - word.length + 1));
                           for (let j = 0; j < word.length; j++) if(grid[r][c+j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r][c+j] = wordToPlace[j];
                           break;
                        case 1:
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * GRID_SIZE.cols);
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c] = wordToPlace[j];
                           break;
                        case 2:
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * (GRID_SIZE.cols - word.length + 1));
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c+j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c+j] = wordToPlace[j];
                           break;
                        case 3:
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * (GRID_SIZE.cols - word.length + 1)) + (word.length -1);
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c-j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c-j] = wordToPlace[j];
                           break;
                    }
                    if(canPlace) placed = true;
                }
            }
            
            for (let r = 0; r < GRID_SIZE.rows; r++) {
                for (let c = 0; c < GRID_SIZE.cols; c++) {
                    if (grid[r][c] === '') {
                        grid[r][c] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(Math.random() * 26)];
                    }
                }
            }
            return { targetWords: targetWords.map(w=>w.toUpperCase()), grid };
        }

        function startNewGame(targetWords, grid) {
            mainStatusEl.textContent = 'Find words from 4 to 6 letters!';
            if (myPlayer) myPlayer.reset();
            if (opponentPlayer) opponentPlayer.reset();
            
            myPlayer.setupBoard(targetWords, grid);
            opponentPlayer.setupBoard(targetWords, grid);
            
            let timeLeft = GAME_DURATION;
            if(gameTimer) clearInterval(gameTimer);
            timerDisplay.textContent = `Time: 2:00`;
            timerDisplay.classList.remove('shake');

            gameTimer = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerDisplay.textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                if (timeLeft === 10) {
                    timerDisplay.classList.add('shake');
                }
                
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }

        function endGame() {
            clearInterval(gameTimer);
            timerDisplay.textContent = "Time's Up!";
            myPlayer.boardEl.classList.add('disabled');
            timerDisplay.classList.remove('shake');
            
            let myResult, myText;
            if (myPlayer.score > opponentPlayer.score) { myResult = 'winner'; myText = 'WINNER!'; } 
            else if (myPlayer.score < opponentPlayer.score) { myResult = 'loser'; myText = 'SO CLOSE!'; } 
            else { myResult = 'draw'; myText = 'DRAW!'; }
            
            const myOverlay = document.createElement('div');
            myOverlay.className = `result-overlay ${myResult}`;
            myOverlay.textContent = myText;
            myPlayer.areaEl.appendChild(myOverlay);
            
            const opponentOverlay = document.createElement('div');
            opponentOverlay.className = `result-overlay ${myResult === 'winner' ? 'loser' : myResult === 'loser' ? 'winner' : 'draw'}`;
            opponentOverlay.textContent = `${myResult === 'winner' ? 'SO CLOSE!' : myResult === 'loser' ? 'WINNER!' : 'DRAW!'}`;
            opponentPlayer.areaEl.appendChild(opponentOverlay);
        }

        function handleConnection(isHost) {
            const playerName = playerNameInput.value.trim();
            const playerColor = playerColorInput.value;
            const theme = themeSelect.value;
            const roomName = roomNameInput.value.trim();
            if (!playerName) return alert('Please enter your name.');
            if (!roomName) return alert('Please enter a room name.');
            initializePeer(isHost, roomName, playerName, playerColor, theme);
        }

        createRoomBtn.addEventListener('click', () => handleConnection(true));
        joinRoomBtn.addEventListener('click', () => handleConnection(false));

        newGameBtn.addEventListener('click', () => {
            if (!isHost) return;
            const { targetWords, grid } = generateNewBoard();
            conn.send({ type: 'start_game', targetWords, grid });
            startNewGame(targetWords, grid);
        });
    </script>
</body>
</html>
