<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Head-to-Head Strands</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --board-bg: #FFFFFF;
            --cell-border: #E0E0E0;
            --text-color: #333;
            --selected-bg: #4A90E2;
            --found-bg: #DDF9E3;
            --found-text: #2B733A;
            --spangram-bg: #FDF4D8;
            --spangram-text: #B58A00;
            --winner-overlay: rgba(0, 0, 0, 0.7);
            --loser-overlay: rgba(50, 50, 50, 0.7);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #F4F4F9;
            color: var(--text-color);
            margin: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        
        #main-status {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            height: 25px;
            text-align: center;
        }
        
        #connection-setup {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
        }

        #connection-setup input {
            padding: 0.5rem;
            border: 1px solid #ccc;
            border-radius: 6px;
        }

        #connection-setup button {
            padding: 0.6rem 1rem;
            font-size: 0.9rem;
            font-weight: 600;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        #create-room-btn { background-color: #28a745; }
        #create-room-btn:hover { background-color: #218838; }
        #join-room-btn { background-color: #007bff; }
        #join-room-btn:hover { background-color: #0069d9; }


        #game-container {
            display: flex;
            justify-content: center;
            gap: 2rem;
            width: 100%;
            max-width: 1200px;
        }

        .player-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }
        
        .result-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            font-weight: bold;
            border-radius: 12px;
            z-index: 100;
        }
        .result-overlay.winner { background: var(--winner-overlay); }
        .result-overlay.loser { background: var(--loser-overlay); }


        .board {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
            background-color: var(--board-bg);
            border: 2px solid var(--cell-border);
            border-radius: 12px;
            padding: 10px;
            aspect-ratio: 6 / 8;
            width: 100%;
            max-width: 400px;
            user-select: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            background-color: var(--board-bg);
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            aspect-ratio: 1 / 1;
        }

        .cell.selected { background-color: var(--selected-bg) !important; color: white; transform: scale(1.05); }
        .cell.found { background-color: var(--found-bg); color: var(--found-text); }
        .cell.spangram { background-color: var(--spangram-bg); color: var(--spangram-text); }

        .found-words-list { list-style: none; padding: 0; margin: 1rem 0 0 0; width: 100%; max-width: 400px; text-align: center; }
        .found-words-list li { display: inline-block; background-color: #C3E0F4; color: var(--text-color); padding: 0.5rem 1rem; border-radius: 20px; margin: 4px; font-weight: 500; }
        
        #new-game-btn {
            margin-top: 1.5rem;
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            background-color: #6A5ACD;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: none; /* Initially hidden */
        }
        #new-game-btn:hover { background-color: #483D8B; }
        #new-game-btn:disabled { background-color: #a9a1e4; cursor: not-allowed; }
        
        .disabled { pointer-events: none; opacity: 0.6; }
        .hidden { display: none; }
    </style>
</head>
<body>

    <h1>Head-to-Head Strands</h1>
    <div id="main-status">Create or join a room to start!</div>

    <div id="connection-setup">
        <input type="text" id="room-name-input" placeholder="Enter Room Name">
        <button id="create-room-btn">Create Room</button>
        <button id="join-room-btn">Join Room</button>
    </div>

    <div id="game-container" class="hidden">
        <div class="player-area" id="player1-area">
            <h2>You</h2>
            <h3 id="theme-p1">Theme: ???</h3>
            <div class="board" id="board-p1"></div>
            <ul class="found-words-list" id="found-words-p1"></ul>
        </div>

        <div class="player-area" id="player2-area">
            <h2>Opponent</h2>
            <h3 id="theme-p2">Theme: ???</h3>
            <div class="board" id="board-p2"></div>
            <ul class="found-words-list" id="found-words-p2"></ul>
        </div>
    </div>
    
    <button id="new-game-btn">New Game</button>

    <script>
        const THEMES = [
            { theme: "IN THE KITCHEN", spangram: "KITCHENUTENSILS", words: ["SPATULA", "WHISK", "LADLE", "COLANDER", "TONGS"] },
            { theme: "HOTEL CALIFORNIA", spangram: "CHECKINGIN", words: ["LOBBY", "KEYCARD", "BELLHOP", "LUGGAGE", "MINIBAR", "VALET"] },
            { theme: "WEATHER WORDS", spangram: "FORECAST", words: ["SUNNY", "CLOUDY", "RAINY", "WINDY", "FOGGY", "STORM"] },
            { theme: "FEELING BLUE", spangram: "SHADESOFBLUE", words: ["NAVY", "INDIGO", "AZURE", "CYAN", "COBALT", "TEAL"] },
            { theme: "CLASSIC ROCK BANDS", spangram: "ROCKANDROLL", words: ["ZEPPELIN", "FLOYD", "QUEEN", "STONES", "EAGLES"] },
            { theme: "COMPUTER PARTS", spangram: "HARDWARE", words: ["MONITOR", "KEYBOARD", "PROCESSOR", "MEMORY", "DRIVE"] }
        ];

        const GRID_SIZE = { rows: 8, cols: 6 };
        let currentTheme, gameActive = false;
        let peer, conn, isHost;
        let myPlayer, opponentPlayer;

        // --- DOM ELEMENTS ---
        const mainStatusEl = document.getElementById('main-status');
        const connectionSetupEl = document.getElementById('connection-setup');
        const roomNameInput = document.getElementById('room-name-input');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const gameContainerEl = document.getElementById('game-container');
        const newGameBtn = document.getElementById('new-game-btn');

        class Player {
            constructor(id, isLocal) {
                this.id = id;
                this.isLocal = isLocal; // Is this the player on this machine?
                this.boardEl = document.getElementById(`board-p${id}`);
                this.themeEl = document.getElementById(`theme-p${id}`);
                this.foundWordsEl = document.getElementById(`found-words-p${id}`);
                this.areaEl = document.getElementById(`player${id}-area`);
                
                this.isSelecting = false;
                this.selectedCells = [];
                this.foundWords = [];

                if (isLocal) {
                    this.boardEl.addEventListener('mousedown', (e) => this.startSelection(e));
                    this.boardEl.addEventListener('mouseover', (e) => this.continueSelection(e));
                    document.addEventListener('mouseup', () => this.endSelection());
                }
            }

            reset() {
                this.foundWords = [];
                this.spangramFound = false;
                this.foundWordsEl.innerHTML = '';
                this.themeEl.textContent = 'Theme: ???';
                this.boardEl.classList.remove('disabled');
                const overlay = this.areaEl.querySelector('.result-overlay');
                if (overlay) overlay.remove();
            }

            setupBoard(theme, grid) {
                this.grid = grid;
                this.currentTheme = theme;
                this.drawBoard();
            }
            
            drawBoard() {
                this.boardEl.innerHTML = '';
                for (let r = 0; r < GRID_SIZE.rows; r++) {
                    for (let c = 0; c < GRID_SIZE.cols; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.r = r;
                        cell.dataset.c = c;
                        cell.textContent = this.grid[r][c];
                        this.boardEl.appendChild(cell);
                    }
                }
            }

            // --- LOCAL PLAYER ONLY METHODS ---
            startSelection(e) {
                if (!gameActive || e.target.classList.contains('found')) return;
                this.isSelecting = true;
                this.selectedCells = [];
                this.addCellToSelection(e.target);
            }

            continueSelection(e) {
                if (!this.isSelecting) return;
                this.addCellToSelection(e.target);
            }
            
            addCellToSelection(cellEl) {
                if (!cellEl.classList.contains('cell') || this.selectedCells.includes(cellEl)) return;
                this.selectedCells.push(cellEl);
                cellEl.classList.add('selected');
            }

            endSelection() {
                if (!this.isSelecting) return;
                this.isSelecting = false;

                const selectedWord = this.selectedCells.map(c => c.textContent).join('');
                this.selectedCells.forEach(cell => cell.classList.remove('selected'));
                this.selectedCells = [];

                const wordData = this.checkWord(selectedWord);
                if (wordData.found) {
                    conn.send({ type: 'word_found', word: selectedWord });
                    this.revealWord(selectedWord, wordData.isSpangram);
                    this.checkWinCondition();
                }
            }
            
            checkWord(word) {
                if (this.foundWords.includes(word)) return { found: false };
                
                const isSpangram = word === this.currentTheme.spangram;
                const isThemeWord = this.currentTheme.words.includes(word);

                return { found: isSpangram || isThemeWord, isSpangram: isSpangram };
            }

            revealWord(word, isSpangram) {
                this.foundWords.push(word);
                // The actual cells on board that make up the word need to be found to be highlighted
                // This is a complex task. For now, we'll just update the UI list.
                 if (isSpangram) {
                    this.spangramFound = true;
                    this.themeEl.textContent = this.currentTheme.theme; // Reveal theme
                } else {
                    const li = document.createElement('li');
                    li.textContent = word;
                    this.foundWordsEl.appendChild(li);
                }
            }
            
            checkWinCondition() {
                 const allThemeWordsFound = this.currentTheme.words.every(w => this.foundWords.includes(w));
                 if (this.spangramFound && allThemeWordsFound) {
                    conn.send({ type: 'win' });
                    endGame(true); // I won
                 }
            }
        }
        
        // --- WEBRTC LOGIC ---
        function initializePeer(host, roomName) {
            isHost = host;
            peer = isHost ? new Peer(roomName) : new Peer();

            peer.on('open', (id) => {
                console.log('My peer ID is: ' + id);
                if (!isHost) {
                    connectToHost(roomName);
                } else {
                    mainStatusEl.textContent = `Room "${roomName}" created. Waiting for opponent...`;
                }
            });

            peer.on('connection', (connection) => {
                console.log('Opponent connected!');
                conn = connection;
                setupConnection();
            });

            peer.on('error', (err) => {
                mainStatusEl.textContent = `Error: ${err.message}`;
                createRoomBtn.disabled = false;
                joinRoomBtn.disabled = false;
            });
        }

        function connectToHost(roomName) {
            conn = peer.connect(roomName);
            setupConnection();
        }

        function setupConnection() {
            conn.on('open', () => {
                connectionSetupEl.classList.add('hidden');
                gameContainerEl.classList.remove('hidden');
                newGameBtn.style.display = 'block';

                myPlayer = new Player(isHost ? 1 : 2, true);
                opponentPlayer = new Player(isHost ? 2 : 1, false);

                if (isHost) {
                    newGameBtn.disabled = false;
                    mainStatusEl.textContent = "Connected! Click 'New Game' to start.";
                } else {
                    newGameBtn.disabled = true;
                    mainStatusEl.textContent = "Connected! Waiting for host to start.";
                }
            });

            conn.on('data', (data) => {
                switch (data.type) {
                    case 'start_game':
                        startNewGame(data.theme, data.grid);
                        break;
                    case 'word_found':
                        const wordData = opponentPlayer.checkWord(data.word);
                        if (wordData.found) {
                            opponentPlayer.revealWord(data.word, wordData.isSpangram);
                        }
                        break;
                    case 'win':
                        endGame(false); // Opponent won
                        break;
                    case 'reset':
                        startNewGame(data.theme, data.grid);
                        break;
                }
            });
            
            conn.on('close', () => {
                mainStatusEl.textContent = "Opponent disconnected.";
                endGame(null); // No winner
            });
        }
        
        // --- GAME LOGIC ---
        function generateNewBoard() {
            const theme = THEMES[Math.floor(Math.random() * THEMES.length)];
            let grid = Array(GRID_SIZE.rows).fill(null).map(() => Array(GRID_SIZE.cols).fill(''));
            
            const allWords = [...theme.words, theme.spangram].sort((a,b) => b.length - a.length);

            for (const word of allWords) {
                let placed = false;
                for (let i = 0; i < 100 && !placed; i++) {
                    const dir = Math.random() < 0.5 ? 'h' : 'v';
                    let r, c;
                    if (dir === 'h') {
                        r = Math.floor(Math.random() * GRID_SIZE.rows);
                        c = Math.floor(Math.random() * (GRID_SIZE.cols - word.length + 1));
                    } else {
                        r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                        c = Math.floor(Math.random() * GRID_SIZE.cols);
                    }
                    
                    let canPlace = true;
                    for (let j = 0; j < word.length; j++) {
                        const checkR = r + (dir === 'v' ? j : 0);
                        const checkC = c + (dir === 'h' ? j : 0);
                        if (grid[checkR][checkC] !== '' && grid[checkR][checkC] !== word[j]) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    if(canPlace) {
                        for (let j = 0; j < word.length; j++) {
                            const placeR = r + (dir === 'v' ? j : 0);
                            const placeC = c + (dir === 'h' ? j : 0);
                            grid[placeR][placeC] = word[j];
                        }
                        placed = true;
                    }
                }
                 if (!placed) console.error("Failed to place: " + word);
            }
            
            for (let r = 0; r < GRID_SIZE.rows; r++) {
                for (let c = 0; c < GRID_SIZE.cols; c++) {
                    if (grid[r][c] === '') {
                        grid[r][c] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(Math.random() * 26)];
                    }
                }
            }
            return { theme, grid };
        }

        function startNewGame(theme, grid) {
            gameActive = true;
            mainStatusEl.textContent = 'Race to the finish!';
            [myPlayer, opponentPlayer].forEach(p => p.reset());
            myPlayer.setupBoard(theme, grid);
            opponentPlayer.setupBoard(theme, grid);
        }

        function endGame(iWon) {
            gameActive = false;
            myPlayer.boardEl.classList.add('disabled');
            opponentPlayer.boardEl.classList.add('disabled');
            
            if (iWon === true) {
                mainStatusEl.textContent = 'You are the winner! 🎉';
                const overlay = document.createElement('div');
                overlay.className = 'result-overlay winner';
                overlay.textContent = 'WINNER!';
                myPlayer.areaEl.appendChild(overlay);
            } else if (iWon === false) {
                mainStatusEl.textContent = 'Your opponent won!';
                const overlay = document.createElement('div');
                overlay.className = 'result-overlay loser';
                overlay.textContent = 'SO CLOSE!';
                myPlayer.areaEl.appendChild(overlay);
            }
        }

        // --- EVENT LISTENERS ---
        createRoomBtn.addEventListener('click', () => {
            const roomName = roomNameInput.value.trim();
            if (!roomName) return alert('Please enter a room name.');
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            initializePeer(true, roomName);
        });

        joinRoomBtn.addEventListener('click', () => {
            const roomName = roomNameInput.value.trim();
            if (!roomName) return alert('Please enter a room name.');
            createRoomBtn.disabled = true;
            joinRoomBtn.disabled = true;
            initializePeer(false, roomName);
        });

        newGameBtn.addEventListener('click', () => {
            if (!isHost) return;
            const { theme, grid } = generateNewBoard();
            conn.send({ type: 'start_game', theme, grid });
            startNewGame(theme, grid);
        });
    </script>
</body>
</html>
