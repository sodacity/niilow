<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Discovery Battle</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --board-bg: #FFFFFF;
            --cell-border: #E0E0E0;
            --text-color: #333;
            --selected-bg: #4A90E2;
            --opponent-selected-bg: #FFB6C1;
            --bonus-word-color: #28a745;
            --winner-overlay: rgba(40, 167, 69, 0.8);
            --loser-overlay: rgba(220, 53, 69, 0.8);
            --draw-overlay: rgba(108, 117, 125, 0.8);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #F4F4F9;
            color: var(--text-color);
            margin: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
        }

        #game-header { text-align: center; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        #main-status { font-size: 1.2rem; font-weight: 600; margin-bottom: 1rem; height: 25px; }
        
        #connection-setup { display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1rem; align-items: center; background-color: #fff; padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .input-group { display: flex; gap: 0.5rem; width: 100%; justify-content: center; }
        #connection-setup input { padding: 0.75rem; border: 1px solid #ccc; border-radius: 8px; font-size: 1rem; }
        #connection-setup button { padding: 0.75rem 1rem; font-size: 1rem; font-weight: 600; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
        #create-room-btn { background-color: #28a745; }
        #join-room-btn { background-color: #007bff; }

        #game-area { display: none; flex-direction: column; align-items: center; width: 100%; }
        #game-info { display: flex; justify-content: space-around; width: 100%; max-width: 800px; margin-bottom: 1rem; font-size: 1.5rem; font-weight: bold; }
        #timer-display { color: #DC3545; }

        #game-container { display: flex; justify-content: center; gap: 2rem; width: 100%; max-width: 1200px; align-items: flex-start; }
        .player-area { flex: 1; display: flex; flex-direction: column; align-items: center; position: relative; }
        
        .result-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; color: white; display: flex; align-items: center; justify-content: center; font-size: 3rem; font-weight: bold; border-radius: 12px; z-index: 100; text-shadow: 2px 2px 4px #000; }
        .result-overlay.winner { background: var(--winner-overlay); }
        .result-overlay.loser { background: var(--loser-overlay); }
        .result-overlay.draw { background: var(--draw-overlay); }

        .board { display: grid; grid-template-columns: repeat(10, 1fr); gap: 4px; background-color: var(--board-bg); border: 2px solid var(--cell-border); border-radius: 12px; padding: 10px; aspect-ratio: 10 / 12; width: 100%; max-width: 500px; user-select: none; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .cell { display: flex; align-items: center; justify-content: center; font-size: 1.2rem; font-weight: bold; background-color: var(--board-bg); border-radius: 8px; cursor: pointer; transition: background-color 0.1s; aspect-ratio: 1 / 1; }
        .cell.selected { background-color: var(--selected-bg) !important; color: white; }
        .cell.opponent-selecting { background-color: var(--opponent-selected-bg) !important; }
        
        .score-display { font-size: 2.5rem; font-weight: bold; margin-top: 1rem; }
        
        .words-display-area { margin-top: 1rem; width: 100%; max-width: 400px; text-align: center; }
        .words-display-area h3 { margin-bottom: 0.5rem; }
        .found-words-list, .bonus-word-list { list-style: none; padding: 0.5rem; margin: 0; height: 100px; overflow-y: auto; background-color: #f0f0f0; border-radius: 8px; border: 1px solid #ddd; }
        .found-words-list li { color: #333; }
        .bonus-word-list li { font-weight: 600; color: var(--bonus-word-color); }

        #new-game-btn { margin-top: 1.5rem; padding: 0.8rem 1.5rem; font-size: 1rem; font-weight: 600; color: white; background-color: #6A5ACD; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; display: none; }
        #new-game-btn:disabled { background-color: #a9a1e4; cursor: not-allowed; }
    </style>
</head>
<body>

    <div id="game-header">
        <h1>Word Discovery Battle</h1>
        <div id="main-status">Enter your name to begin!</div>
    </div>

    <div id="connection-setup">
        <input type="text" id="player-name-input" placeholder="Your Name">
        <div class="input-group">
            <input type="text" id="room-name-input" placeholder="Room Name">
            <button id="create-room-btn">Create</button>
            <button id="join-room-btn">Join</button>
        </div>
    </div>

    <div id="game-area">
        <div id="game-info">
            <div id="timer-display">Time: 2:00</div>
        </div>
        <div id="game-container">
            <div class="player-area" id="player1-area">
                <h2 id="name-p1">You</h2>
                <div class="board" id="board-p1"></div>
                <div class="score-display" id="score-p1">Score: 0</div>
                <div class="words-display-area">
                    <h3>Your Found Words:</h3>
                    <ul class="found-words-list" id="found-words-p1"></ul>
                </div>
                <div class="words-display-area">
                    <h3>Bonus Words Found:</h3>
                    <ul class="bonus-word-list" id="bonus-words-p1"></ul>
                </div>
            </div>
            <div class="player-area" id="player2-area">
                <h2 id="name-p2">Opponent</h2>
                <div class="board" id="board-p2"></div>
                <div class="score-display" id="score-p2">Score: 0</div>
                <div class="words-display-area">
                    <h3>Opponent's Bonus Words:</h3>
                    <ul class="bonus-word-list" id="bonus-words-p2"></ul>
                </div>
            </div>
        </div>
    </div>
    
    <button id="new-game-btn">New Game</button>

    <script>
        // NOTE: This dictionary is greatly expanded, but not exhaustive.
        const DICTIONARY_WORDS = ["a", "able", "about", "above", "act", "add", "afraid", "after", "again", "age", "ago", "agree", "air", "all", "allow", "also", "always", "am", "among", "an", "and", "anger", "animal", "answer", "any", "appear", "apple", "are", "area", "arm", "arrange", "arrive", "art", "as", "ask", "at", "atom", "baby", "back", "bad", "ball", "banana", "band", "bank", "bar", "base", "basic", "bat", "be", "bear", "beat", "beauty", "bed", "been", "before", "began", "begin", "behind", "believe", "bell", "best", "better", "between", "big", "bird", "bit", "black", "block", "blood", "blow", "blue", "board", "boat", "body", "bone", "book", "born", "both", "bottom", "bought", "box", "boy", "branch", "bread", "break", "bright", "bring", "broad", "broke", "brother", "brought", "brown", "build", "burn", "bus", "busy", "but", "buy", "by", "call", "came", "camp", "can", "capital", "captain", "car", "card", "care", "carry", "case", "cat", "catch", "caught", "cause", "cell", "cent", "center", "century", "certain", "chair", "chance", "change", "character", "charge", "chart", "check", "cherry", "chick", "chief", "child", "children", "choose", "chord", "circle", "city", "claim", "class", "clean", "clear", "climb", "clock", "close", "clothe", "cloud", "coast", "coat", "code", "cold", "collect", "colony", "color", "column", "come", "comet", "common", "company", "compare", "complete", "condition", "connect", "consider", "consonant", "contain", "continent", "continue", "control", "cook", "cool", "copy", "corn", "corner", "correct", "cost", "cot", "cotton", "could", "count", "country", "course", "cover", "cow", "crease", "create", "crop", "cross", "crowd", "cry", "current", "cut", "dad", "dance", "danger", "dark", "data", "day", "dead", "deal", "dear", "death", "decide", "decimal", "deep", "degree", "depend", "describe", "desert", "design", "determine", "develop", "dictionary", "did", "die", "differ", "difficult", "direct", "discover", "discuss", "distant", "divide", "division", "do", "doctor", "doe", "dog", "dollar", "done", "door", "dot", "double", "down", "draw", "dream", "dress", "drink", "drive", "drop", "drove", "dry", "duck", "during", "each", "ear", "early", "earth", "ease", "east", "eat", "edge", "effect", "egg", "eight", "either", "electric", "element", "else", "end", "enemy", "energy", "engine", "enough", "enter", "equal", "equate", "especially", "even", "evening", "event", "ever", "every", "exact", "example", "except", "excite", "exercise", "expect", "experience", "experiment", "eye", "face", "fact", "fair", "fall", "family", "famous", "far", "farm", "fast", "fat", "father", "favor", "fear", "feed", "feel", "feet", "fell", "felt", "few", "field", "fig", "fight", "figure", "fill", "final", "find", "fine", "finger", "finish", "fire", "first", "fish", "fit", "five", "flat", "floor", "flow", "flower", "fly", "follow", "food", "foot", "for", "force", "forest", "form", "forward", "found", "four", "fraction", "free", "fresh", "friend", "from", "front", "fruit", "fry", "full", "fun", "game", "galaxy", "garden", "gas", "gather", "gave", "general", "gentle", "get", "girl", "give", "glad", "glass", "go", "gold", "gone", "good", "got", "govern", "grand", "grape", "grass", "gray", "great", "green", "grew", "ground", "group", "grow", "guess", "guide", "gun", "had", "hair", "half", "hand", "happen", "happy", "hard", "has", "hat", "have", "he", "head", "hear", "heard", "heart", "heat", "heavy", "held", "help", "her", "here", "high", "hill", "him", "his", "history", "hit", "hold", "hole", "home", "hope", "horse", "hot", "hour", "house", "how", "html", "huge", "human", "hundred", "hunt", "hurry", "i", "ice", "idea", "if", "imagine", "in", "inch", "include", "indicate", "industry", "insect", "instant", "instrument", "interest", "invent", "iron", "is", "island", "it", "its", "java", "jet", "job", "join", "joy", "jump", "just", "keep", "kept", "key", "kid", "kill", "kind", "king", "knew", "know", "lad", "lady", "lake", "land", "language", "large", "last", "late", "laugh", "law", "lay", "lead", "learn", "least", "leave", "led", "left", "leg", "lemon", "length", "less", "let", "letter", "level", "lie", "life", "lift", "light", "like", "lime", "line", "liquid", "list", "listen", "little", "live", "locate", "log", "lone", "long", "look", "loop", "lost", "lot", "loud", "love", "low", "luck", "machine", "made", "magnet", "main", "major", "make", "man", "many", "map", "mark", "market", "mars", "mass", "master", "match", "material", "matter", "may", "me", "mean", "meant", "measure", "meat", "meet", "melody", "men", "metal", "method", "middle", "might", "mile", "milk", "million", "mind", "mine", "minute", "miss", "mix", "modern", "molecule", "moment", "money", "month", "moon", "more", "morning", "most", "mother", "motion", "mount", "mouse", "mouth", "move", "much", "multiply", "music", "must", "my", "name", "nation", "natural", "nature", "near", "necessary", "neck", "need", "neighbor", "never", "new", "next", "night", "nine", "no", "noise", "noon", "nor", "north", "nose", "not", "note", "nothing", "notice", "noun", "now", "number", "object", "observe", "occur", "ocean", "of", "off", "offer", "office", "often", "oh", "oil", "old", "on", "once", "one", "only", "open", "operate", "opposite", "or", "orange", "order", "organ", "original", "other", "our", "out", "over", "own", "oxygen", "pack", "pad", "page", "paid", "paint", "pair", "paper", "paragraph", "parent", "park", "part", "particular", "party", "pass", "past", "path", "pattern", "pay", "peach", "pear", "pen", "pencil", "people", "per", "perhaps", "period", "person", "phrase", "pick", "picture", "piece", "pig", "pine", "pink", "pipe", "pitch", "place", "plain", "plan", "plane", "planet", "plant", "plate", "play", "please", "plural", "plum", "poem", "point", "pole", "populate", "port", "pose", "position", "possible", "post", "pound", "power", "practice", "prepare", "present", "press", "pretty", "print", "probable", "problem", "process", "produce", "product", "program", "proof", "proper", "protect", "provide", "pull", "punish", "push", "put", "python", "quart", "queen", "question", "quick", "quiet", "quite", "quotient", "race", "radio", "rail", "rain", "raise", "ran", "range", "rather", "reach", "read", "ready", "real", "reason", "receive", "record", "red", "region", "remember", "repeat", "reply", "represent", "require", "rest", "result", "rich", "ride", "right", "ring", "rise", "river", "road", "rock", "rocket", "roll", "room", "root", "rope", "rose", "round", "row", "rub", "rule", "run", "safe", "said", "sail", "salt", "same", "sand", "sat", "save", "saw", "say", "scale", "school", "science", "score", "script", "sea", "search", "season", "seat", "second", "secret", "section", "see", "seed", "seem", "segment", "select", "self", "sell", "send", "sense", "sent", "sentence", "separate", "serve", "server", "set", "settle", "seven", "several", "shall", "shape", "share", "sharp", "she", "sheet", "shell", "shine", "ship", "shoe", "shop", "shore", "short", "should", "shoulder", "shout", "show", "side", "sight", "sign", "signal", "silent", "similar", "simple", "since", "sing", "single", "sit", "six", "size", "skill", "skin", "sky", "slave", "sleep", "slip", "slow", "small", "smell", "smile", "snow", "so", "soft", "soil", "solar", "soldier", "solution", "solve", "some", "son", "song", "soon", "sort", "sound", "south", "space", "speak", "special", "speech", "speed", "spell", "spend", "spoke", "spot", "spread", "spring", "square", "stand", "star", "start", "state", "station", "stay", "stead", "steam", "steel", "step", "stick", "still", "stone", "stood", "stop", "store", "story", "straight", "strange", "stream", "street", "stretch", "string", "strong", "student", "study", "subject", "substance", "subtract", "such", "sudden", "suffix", "sugar", "suggest", "suit", "summer", "sun", "supply", "support", "sure", "surface", "surprise", "swim", "swift", "syllable", "symbol", "system", "table", "tail", "take", "talk", "tall", "teach", "team", "tell", "temperature", "ten", "term", "test", "than", "thank", "that", "the", "their", "them", "then", "there", "these", "they", "thick", "thin", "thing", "think", "third", "this", "those", "though", "thought", "thousand", "three", "through", "throw", "thus", "tide", "tie", "time", "tin", "tiny", "tip", "tire", "to", "together", "told", "tone", "too", "took", "tool", "top", "total", "touch", "town", "track", "trade", "train", "transport", "travel", "tree", "triangle", "trip", "trouble", "truck", "true", "try", "tube", "turn", "twenty", "two", "type", "under", "unit", "until", "up", "us", "use", "usual", "valley", "valuable", "value", "vapor", "variety", "various", "verb", "venus", "very", "view", "village", "visit", "voice", "vowel", "wait", "walk", "wall", "want", "war", "warm", "was", "wash", "watch", "water", "wave", "way", "we", "wear", "weather", "week", "weight", "well", "went", "were", "west", "wet", "what", "wheel", "when", "where", "whether", "which", "while", "white", "who", "whole", "whose", "why", "wide", "wife", "wild", "will", "win", "wind", "window", "wing", "winter", "wire", "wish", "with", "woman", "women", "won", "wonder", "wood", "word", "work", "world", "would", "write", "written", "wrong", "wrote", "yard", "year", "yellow", "yes", "yet", "you", "young", "your", "zoo"];
        const FULL_DICTIONARY = new Set(DICTIONARY_WORDS.map(w => w.toUpperCase()));
        
        const GRID_SIZE = { rows: 12, cols: 10 };
        const GAME_DURATION = 120; // 2 minutes in seconds

        let peer, conn, isHost, gameTimer;
        let myPlayer, opponentPlayer;

        // --- DOM ELEMENTS ---
        const mainStatusEl = document.getElementById('main-status');
        const connectionSetupEl = document.getElementById('connection-setup');
        const playerNameInput = document.getElementById('player-name-input');
        const roomNameInput = document.getElementById('room-name-input');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const gameAreaEl = document.getElementById('game-area');
        const newGameBtn = document.getElementById('new-game-btn');
        const timerDisplay = document.getElementById('timer-display');
        
        class Player {
            constructor(id, name, isLocal) {
                this.id = id;
                this.name = name;
                this.isLocal = isLocal;
                this.boardEl = document.getElementById(`board-p${id}`);
                this.scoreEl = document.getElementById(`score-p${id}`);
                this.nameEl = document.getElementById(`name-p${id}`);
                this.bonusWordListEl = document.getElementById(`bonus-words-p${id}`);
                this.foundWordsListEl = this.isLocal ? document.getElementById(`found-words-p${id}`) : null;
                this.areaEl = document.getElementById(`player${id}-area`);
                
                this.nameEl.textContent = this.name;
                this.score = 0;
                this.foundWords = new Set();
                this.isDragging = false;
                this.selectedCells = [];

                if (isLocal) {
                    this.boardEl.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                    this.boardEl.addEventListener('mouseover', (e) => this.handleMouseOver(e));
                    document.addEventListener('mouseup', () => this.handleMouseUp());
                }
            }

            reset() {
                this.score = 0;
                this.foundWords.clear();
                this.bonusWordListEl.innerHTML = '';
                if(this.foundWordsListEl) this.foundWordsListEl.innerHTML = '';
                this.boardEl.classList.remove('disabled');
                const overlay = this.areaEl.querySelector('.result-overlay');
                if (overlay) overlay.remove();
                this.updateScore(0);
            }

            setupBoard(targetWords, grid) {
                this.targetWords = new Set(targetWords);
                this.grid = grid;
                this.drawBoard();
            }
            
            drawBoard() {
                this.boardEl.innerHTML = '';
                for (let r = 0; r < GRID_SIZE.rows; r++) {
                    for (let c = 0; c < GRID_SIZE.cols; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.r = r;
                        cell.dataset.c = c;
                        cell.textContent = this.grid[r][c];
                        this.boardEl.appendChild(cell);
                    }
                }
            }
            
            updateScore(newScore) {
                this.score = newScore;
                this.scoreEl.textContent = `Score: ${this.score}`;
            }

            addBonusWord(word) {
                const li = document.createElement('li');
                li.textContent = word;
                this.bonusWordListEl.appendChild(li);
            }

            addFoundWord(word) {
                if (!this.foundWordsListEl) return;
                const li = document.createElement('li');
                li.textContent = word;
                this.foundWordsListEl.appendChild(li);
                this.foundWordsListEl.scrollTop = this.foundWordsListEl.scrollHeight;
            }

            // --- LOCAL PLAYER ONLY METHODS ---
            handleMouseDown(e) {
                if (gameTimer <= 0 || !e.target.classList.contains('cell')) return;
                this.isDragging = true;
                this.clearSelection(); 
                this.addCellToSelection(e.target);
            }

            handleMouseOver(e) {
                if (!this.isDragging || !e.target.classList.contains('cell')) return;
                this.addCellToSelection(e.target);
            }

            handleMouseUp() {
                if (!this.isDragging) return;
                this.isDragging = false;
                this.submitWord();
            }
            
            addCellToSelection(cellEl) {
                if (this.selectedCells.includes(cellEl)) return;
                this.selectedCells.push(cellEl);
                cellEl.classList.add('selected');
                this.sendSelectionUpdate();
            }

            clearSelection() {
                this.selectedCells.forEach(cell => cell.classList.remove('selected'));
                this.selectedCells = [];
                this.sendSelectionUpdate();
            }
            
            sendSelectionUpdate() {
                 conn.send({ type: 'selection_update', path: this.selectedCells.map(c => ({ r: c.dataset.r, c: c.dataset.c })) });
            }

            submitWord() {
                if (this.selectedCells.length === 0) return;

                const selectedWord = this.selectedCells.map(c => c.textContent).join('');
                this.validateAndScoreWord(selectedWord);
                this.validateAndScoreWord(selectedWord.split('').reverse().join(''));
                
                this.clearSelection();
            }

            validateAndScoreWord(word) {
                const upperWord = word.toUpperCase();
                if (word.length < 3 || this.foundWords.has(upperWord) || !FULL_DICTIONARY.has(upperWord)) {
                    return;
                }

                this.foundWords.add(upperWord);
                this.addFoundWord(word); // Add to local player's list

                let points = word.length;
                let isBonus = this.targetWords.has(upperWord);

                if (isBonus) {
                    points += 10;
                    this.addBonusWord(upperWord);
                }

                this.updateScore(this.score + points);
                conn.send({ type: 'word_found', word: upperWord, newScore: this.score, isBonus });
            }
            
            // --- OPPONENT ONLY METHODS ---
            updateOpponentSelection(path) {
                this.boardEl.querySelectorAll('.opponent-selecting').forEach(c => c.classList.remove('opponent-selecting'));
                path.forEach(pos => {
                    const cell = this.boardEl.querySelector(`[data-r='${pos.r}'][data-c='${pos.c}']`);
                    if (cell) cell.classList.add('opponent-selecting');
                });
            }
        }
        
        // --- WEBRTC LOGIC ---
        function initializePeer(host, roomName, playerName) {
            isHost = host;
            peer = isHost ? new Peer(roomName) : new Peer();

            peer.on('open', (id) => {
                if (!isHost) connectToHost(roomName, playerName);
                else mainStatusEl.textContent = `Room "${roomName}" created. Waiting...`;
            });

            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection(playerName);
            });
            peer.on('error', (err) => { mainStatusEl.textContent = `Error: ${err.message}`; });
        }

        function connectToHost(roomName, playerName) {
            conn = peer.connect(roomName);
            setupConnection(playerName);
        }

        function setupConnection(myName) {
            conn.on('open', () => {
                // Exchange names
                conn.send({ type: 'name_sync', name: myName });
                
                connectionSetupEl.style.display = 'none';
                gameAreaEl.style.display = 'flex';
                newGameBtn.style.display = 'block';

                myPlayer = new Player(isHost ? 1 : 2, myName, true);
            });

            conn.on('data', (data) => {
                switch (data.type) {
                    case 'name_sync':
                        opponentPlayer = new Player(isHost ? 2 : 1, data.name, false);
                         if (isHost) {
                            newGameBtn.disabled = false;
                            mainStatusEl.textContent = `Connected to ${data.name}! Click 'New Game' to start.`;
                        } else {
                            newGameBtn.disabled = true;
                            mainStatusEl.textContent = `Connected to ${data.name}! Waiting for them to start.`;
                        }
                        break;
                    case 'start_game':
                        startNewGame(data.targetWords, data.grid);
                        break;
                    case 'selection_update':
                        if(opponentPlayer) opponentPlayer.updateOpponentSelection(data.path);
                        break;
                    case 'word_found':
                        if(opponentPlayer) {
                            opponentPlayer.updateScore(data.newScore);
                            if (data.isBonus) {
                                opponentPlayer.addBonusWord(data.word);
                            }
                        }
                        break;
                }
            });
            
            conn.on('close', () => {
                mainStatusEl.textContent = "Opponent disconnected.";
                if(gameTimer) clearInterval(gameTimer);
            });
        }
        
        // --- GAME LOGIC ---
        function generateNewBoard() {
             const targetWords = [...new Set(DICTIONARY_WORDS.filter(w=>w.length > 4))].sort(() => 0.5 - Math.random()).slice(0, 10);
            targetWords.sort((a,b) => b.length - a.length);

            let grid = Array(GRID_SIZE.rows).fill(null).map(() => Array(GRID_SIZE.cols).fill(''));
            
            for (const word of targetWords) {
                let placed = false;
                for (let i = 0; i < 200 && !placed; i++) {
                    const dir = Math.floor(Math.random() * 4);
                    const wordToPlace = word.toUpperCase();
                    
                    let r, c, canPlace = true;

                    switch(dir) {
                        case 0: // horizontal
                           r = Math.floor(Math.random() * GRID_SIZE.rows);
                           c = Math.floor(Math.random() * (GRID_SIZE.cols - word.length + 1));
                           for (let j = 0; j < word.length; j++) if(grid[r][c+j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r][c+j] = wordToPlace[j];
                           break;
                        case 1: // vertical
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * GRID_SIZE.cols);
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c] = wordToPlace[j];
                           break;
                        case 2: // diagonal down-right
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * (GRID_SIZE.cols - word.length + 1));
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c+j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c+j] = wordToPlace[j];
                           break;
                        case 3: // diagonal down-left
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * (GRID_SIZE.cols - (word.length -1))) + (word.length-1);
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c-j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c-j] = wordToPlace[j];
                           break;
                    }
                    if(canPlace) placed = true;
                }
            }
            
            for (let r = 0; r < GRID_SIZE.rows; r++) {
                for (let c = 0; c < GRID_SIZE.cols; c++) {
                    if (grid[r][c] === '') {
                        grid[r][c] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(Math.random() * 26)];
                    }
                }
            }
            return { targetWords: targetWords.map(w=>w.toUpperCase()), grid };
        }

        function startNewGame(targetWords, grid) {
            mainStatusEl.textContent = 'Find as many words as you can!';
            [myPlayer, opponentPlayer].forEach(p => p.reset());
            myPlayer.setupBoard(targetWords, grid);
            opponentPlayer.setupBoard(targetWords, grid);
            
            let timeLeft = GAME_DURATION;
            if(gameTimer) clearInterval(gameTimer);
            timerDisplay.textContent = `Time: 2:00`;

            gameTimer = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerDisplay.textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;

                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }

        function endGame() {
            clearInterval(gameTimer);
            timerDisplay.textContent = "Time's Up!";
            myPlayer.boardEl.classList.add('disabled');
            
            let myResult, myText;
            if (myPlayer.score > opponentPlayer.score) { myResult = 'winner'; myText = 'WINNER!'; } 
            else if (myPlayer.score < opponentPlayer.score) { myResult = 'loser'; myText = 'SO CLOSE!'; } 
            else { myResult = 'draw'; myText = 'DRAW!'; }
            
            const myOverlay = document.createElement('div');
            myOverlay.className = `result-overlay ${myResult}`;
            myOverlay.textContent = myText;
            myPlayer.areaEl.appendChild(myOverlay);
            
            const opponentOverlay = document.createElement('div');
            opponentOverlay.className = `result-overlay ${myResult === 'winner' ? 'loser' : myResult === 'loser' ? 'winner' : 'draw'}`;
            opponentOverlay.textContent = `${myResult === 'winner' ? 'SO CLOSE!' : myResult === 'loser' ? 'WINNER!' : 'DRAW!'}`;
            opponentPlayer.areaEl.appendChild(opponentOverlay);
        }

        // --- EVENT LISTENERS ---
        function handleConnection(isHost) {
            const playerName = playerNameInput.value.trim();
            const roomName = roomNameInput.value.trim();
            if (!playerName) return alert('Please enter your name.');
            if (!roomName) return alert('Please enter a room name.');
            initializePeer(isHost, roomName, playerName);
        }

        createRoomBtn.addEventListener('click', () => handleConnection(true));
        joinRoomBtn.addEventListener('click', () => handleConnection(false));

        newGameBtn.addEventListener('click', () => {
            if (!isHost) return;
            const { targetWords, grid } = generateNewBoard();
            conn.send({ type: 'start_game', targetWords, grid });
            startNewGame(targetWords, grid);
        });
    </script>
</body>
</html>
