<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Discovery Battle</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --board-bg: #FFFFFF;
            --cell-border: #E0E0E0;
            --text-color: #333;
            --selected-bg: #4A90E2;
            --opponent-selected-bg: #FFB6C1;
            --bonus-word-color: #28a745;
            --winner-overlay: rgba(40, 167, 69, 0.8);
            --loser-overlay: rgba(220, 53, 69, 0.8);
            --draw-overlay: rgba(108, 117, 125, 0.8);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #F4F4F9;
            color: var(--text-color);
            margin: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
        }

        #game-header { text-align: center; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        #main-status { font-size: 1.2rem; font-weight: 600; margin-bottom: 1rem; height: 25px; }
        
        #connection-setup { display: flex; gap: 1rem; margin-bottom: 1rem; align-items: center; }
        #connection-setup input { padding: 0.5rem; border: 1px solid #ccc; border-radius: 6px; }
        #connection-setup button { padding: 0.6rem 1rem; font-size: 0.9rem; font-weight: 600; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
        #create-room-btn { background-color: #28a745; }
        #join-room-btn { background-color: #007bff; }

        #game-area { display: none; flex-direction: column; align-items: center; width: 100%; }
        #game-info { display: flex; justify-content: space-around; width: 100%; max-width: 800px; margin-bottom: 1rem; font-size: 1.5rem; font-weight: bold; }
        #timer-display { color: #DC3545; }

        #game-container { display: flex; justify-content: center; gap: 2rem; width: 100%; max-width: 1200px; }
        .player-area { flex: 1; display: flex; flex-direction: column; align-items: center; position: relative; }
        
        .result-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; color: white; display: flex; align-items: center; justify-content: center; font-size: 3rem; font-weight: bold; border-radius: 12px; z-index: 100; text-shadow: 2px 2px 4px #000; }
        .result-overlay.winner { background: var(--winner-overlay); }
        .result-overlay.loser { background: var(--loser-overlay); }
        .result-overlay.draw { background: var(--draw-overlay); }

        .board { display: grid; grid-template-columns: repeat(10, 1fr); gap: 4px; background-color: var(--board-bg); border: 2px solid var(--cell-border); border-radius: 12px; padding: 10px; aspect-ratio: 10 / 12; width: 100%; max-width: 500px; user-select: none; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .cell { display: flex; align-items: center; justify-content: center; font-size: 1.2rem; font-weight: bold; background-color: var(--board-bg); border-radius: 8px; cursor: pointer; transition: background-color 0.1s; aspect-ratio: 1 / 1; }
        .cell.selected { background-color: var(--selected-bg) !important; color: white; }
        .cell.opponent-selecting { background-color: var(--opponent-selected-bg) !important; }
        
        .score-display {
            font-size: 2.5rem;
            font-weight: bold;
            margin-top: 1rem;
        }

        .bonus-word-area { margin-top: 1rem; width: 100%; max-width: 400px; text-align: center; }
        .bonus-word-list { list-style: none; padding: 0; margin: 0; column-count: 2; }
        .bonus-word-list li { padding: 4px; font-weight: 600; color: var(--bonus-word-color); }
        
        #new-game-btn { margin-top: 1.5rem; padding: 0.8rem 1.5rem; font-size: 1rem; font-weight: 600; color: white; background-color: #6A5ACD; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; display: none; }
        #new-game-btn:disabled { background-color: #a9a1e4; cursor: not-allowed; }
    </style>
</head>
<body>

    <div id="game-header">
        <h1>Word Discovery Battle</h1>
        <div id="main-status">Create or join a room to start!</div>
    </div>

    <div id="connection-setup">
        <input type="text" id="room-name-input" placeholder="Enter Room Name">
        <button id="create-room-btn">Create Room</button>
        <button id="join-room-btn">Join Room</button>
    </div>

    <div id="game-area">
        <div id="game-info">
            <div id="timer-display">Time: 2:00</div>
        </div>
        <div id="game-container">
            <div class="player-area" id="player1-area">
                <h2>You</h2>
                <div class="board" id="board-p1"></div>
                <div class="score-display" id="score-p1">Score: 0</div>
                <div class="bonus-word-area">
                    <h3>Bonus Words Found:</h3>
                    <ul class="bonus-word-list" id="bonus-words-p1"></ul>
                </div>
            </div>
            <div class="player-area" id="player2-area">
                <h2>Opponent</h2>
                <div class="board" id="board-p2"></div>
                <div class="score-display" id="score-p2">Score: 0</div>
                 <div class="bonus-word-area">
                    <h3>Bonus Words Found:</h3>
                    <ul class="bonus-word-list" id="bonus-words-p2"></ul>
                </div>
            </div>
        </div>
    </div>
    
    <button id="new-game-btn">New Game</button>

    <script>
        const TARGET_WORDS_POOL = ["WAVE", "SWIM", "BEACH", "OCEAN", "SAND", "TIDE", "SHELL", "SURF", "COAST", "WATER", "APPLE", "BANANA", "GRAPE", "ORANGE", "PEAR", "LEMON", "LIME", "PEACH", "PLUM", "CHERRY", "PYTHON", "SWIFT", "JAVA", "SCRIPT", "HTML", "CODE", "CLOUD", "SERVER", "CLIENT", "DATA", "PLANET", "STAR", "MOON", "SPACE", "GALAXY", "ROCKET", "COMET", "EARTH", "MARS", "VENUS"];
        const FULL_DICTIONARY = new Set(["ACT", "ADD", "AGE", "AGO", "AID", "AIM", "AIR", "ALL", "AND", "ANY", "APE", "APP", "APT", "ARC", "ARE", "ARM", "ART", "ASH", "ASK", "ATE", "AWL", "AXE", "BAD", "BAG", "BAN", "BAT", "BED", "BEE", "BEG", "BET", "BID", "BIG", "BIN", "BIT", "BOB", "BOG", "BOX", "BOY", "BUD", "BUG", "BUM", "BUN", "BUS", "BUT", "BUY", "BYE", "CAB", "CAD", "CAM", "CAN", "CAP", "CAR", "CAT", "CAW", "CHI", "COD", "COG", "CON", "COO", "COP", "COT", "COW", "CRY", "CUB", "CUD", "CUE", "CUP", "CUR", "CUT", "DAB", "DAD", "DAM", "DAY", "DEW", "DID", "DIE", "DIG", "DIM", "DIN", "DIP", "DOE", "DOG", "DON", "DOT", "DRY", "DUB", "DUD", "DUE", "DUG", "DUH", "DYE", "EAR", "EAT", "EBB", "EEL", "EGG", "EGO", "ELK", "ERA", "ETA", "EVE", "EYE", "FAD", "FAN", "FAR", "FAT", "FED", "FEE", "FEW", "FIG", "FIN", "FIR", "FIT", "FIX", "FLY", "FOB", "FOE", "FOG", "FOR", "FRY", "FUD", "FUG", "FUN", "FUR", "GAG", "GAL", "GAP", "GAS", "GEL", "GEM", "GET", "GIG", "GIN", "GOD", "GOO", "GOT", "GUM", "GUN", "GUT", "GUY", "GYM", "HAD", "HAG", "HAM", "HAS", "HAT", "HAY", "HEM", "HEN", "HER", "HEW", "HEX", "HEY", "HID", "HIM", "HIP", "HIS", "HIT", "HOG", "HOP", "HOT", "HOW", "HUB", "HUE", "HUG", "HUH", "HUM", "HUT", "ICE", "ICY", "IGG", "ILL", "IMP", "INK", "INN", "ION", "IRE", "IRK", "IVY", "JAB", "JAG", "JAM", "JAR", "JAW", "JAY", "JET", "JIG", "JOB", "JOG", "JOT", "JOY", "JUG", "JUT", "KEG", "KEY", "KID", "KIN", "KIT", "LAB", "LAD", "LAG", "LAP", "LAW", "LAY", "LEA", "LED", "LEE", "LEG", "LET", "LID", "LIE", "LIP", "LIT", "LOG", "LOP", "LOT", "LOW", "LUG", "LYE", "MAD", "MAN", "MAP", "MAR", "MAT", "MAW", "MAY", "MEN", "MET", "Mew", "MID", "MIG", "MIL", "MOB", "MOD", "MOL", "MOM", "MOP", "MOW", "MUD", "MUG", "MUM", "NAB", "NAG", "NAP", "NAY", "NET", "NEW", "NIB", "NIL", "NIP", "NIT", "NOB", "NOD", "NOR", "NOT", "NOW", "NUN", "NUT", "OAF", "OAK", "OAR", "OAT", "ODD", "ODE", "OFF", "OFT", "OHM", "OHO", "OIL", "OLD", "ONE", "ORB", "ORE", "OWL", "OWN", "PAD", "PAL", "PAN", "PAP", "PAR", "PAT", "PAW", "PAY", "PEA", "PEG", "PEN", "PEP", "PER", "PET", "PEW", "PHI", "PIE", "PIG", "PIN", "PIT", "PLY", "POD", "POI", "POP", "POT", "PRO", "PRY", "PUB", "PUD", "PUG", "PUN", "PUP", "PUT", "QUO", "RAD", "RAG", "RAM", "RAN", "RAP", "RAT", "RAW", "RAY", "RED", "REP", "RIB", "RID", "RIG", "RIM", "RIP", "ROB", "ROD", "ROE", "ROT", "ROW", "RUB", "RUE", "RUG", "RUM", "RUN", "RUT", "RYE", "SAD", "SAG", "SAP", "SAT", "SAW", "SAY", "SEA", "SEC", "SEE", "SET", "SEW", "SEX", "SHY", "SIN", "SIP", "SIR", "SIS", "SIT", "SKI", "SLY", "SOB", "SOD", "SON", "SOP", "SOW", "SOY", "SPY", "STY", "SUB", "SUE", "SUM", "SUN", "SUP", "TAB", "TAD", "TAG", "TAN", "TAP", "TAR", "TEA", "TED", "TEE", "TEN", "THE", "THY", "TIC", "TIE", "TIL", "TIN", "TIP", "TOE", "TOG", "TOM", "TON", "TOO", "TOP", "TOW", "TOY", "TRY", "TUB", "TUG", "TUI", "TUM", "TUN", "TWO", "USE", "VAN", "VAT", "VET", "VIE", "VOW", "WAB", "WAD", "WAG", "WAR", "WAS", "WAX", "WAY", "WEB", "WED", "WEE", "WET", "WHO", "WHY", "WIG", "WIN", "WIT", "WOE", "WOK", "WON", "WOO", "WOW", "WRY", "YAK", "YAM", "YAP", "YAW", "YEA", "YEN", "YEP", "YES", "YET", "YIN", "YIP", "YOU", "YUK", "YUM", "ZAP", "ZED", "ZEE", "ZEN", "ZIG", "ZIP", "ZOO", ...TARGET_WORDS_POOL]);
        const GRID_SIZE = { rows: 12, cols: 10 };
        const GAME_DURATION = 120; // 2 minutes in seconds

        let peer, conn, isHost, gameTimer;
        let myPlayer, opponentPlayer;

        // --- DOM ELEMENTS ---
        const mainStatusEl = document.getElementById('main-status');
        const connectionSetupEl = document.getElementById('connection-setup');
        const roomNameInput = document.getElementById('room-name-input');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const gameAreaEl = document.getElementById('game-area');
        const newGameBtn = document.getElementById('new-game-btn');
        const timerDisplay = document.getElementById('timer-display');
        
        class Player {
            constructor(id, isLocal) {
                this.id = id;
                this.isLocal = isLocal;
                this.boardEl = document.getElementById(`board-p${id}`);
                this.scoreEl = document.getElementById(`score-p${id}`);
                this.bonusWordListEl = document.getElementById(`bonus-words-p${id}`);
                this.areaEl = document.getElementById(`player${id}-area`);
                
                this.score = 0;
                this.foundWords = new Set();
                this.isDragging = false;
                this.selectedCells = [];

                if (isLocal) {
                    this.boardEl.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                    this.boardEl.addEventListener('mouseover', (e) => this.handleMouseOver(e));
                    // Add global mouseup to handle ending a drag anywhere
                    document.addEventListener('mouseup', () => this.handleMouseUp());
                }
            }

            reset() {
                this.score = 0;
                this.foundWords.clear();
                this.bonusWordListEl.innerHTML = '';
                this.boardEl.classList.remove('disabled');
                const overlay = this.areaEl.querySelector('.result-overlay');
                if (overlay) overlay.remove();
                this.updateScore(0);
            }

            setupBoard(targetWords, grid) {
                this.targetWords = new Set(targetWords);
                this.grid = grid;
                this.drawBoard();
            }
            
            drawBoard() {
                this.boardEl.innerHTML = '';
                for (let r = 0; r < GRID_SIZE.rows; r++) {
                    for (let c = 0; c < GRID_SIZE.cols; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.r = r;
                        cell.dataset.c = c;
                        cell.textContent = this.grid[r][c];
                        this.boardEl.appendChild(cell);
                    }
                }
            }
            
            updateScore(newScore) {
                this.score = newScore;
                this.scoreEl.textContent = `Score: ${this.score}`;
            }

            addBonusWord(word) {
                const li = document.createElement('li');
                li.textContent = word;
                this.bonusWordListEl.appendChild(li);
            }

            // --- LOCAL PLAYER ONLY METHODS ---
            handleMouseDown(e) {
                if (gameTimer <= 0 || !e.target.classList.contains('cell')) return;
                this.isDragging = true;
                // A new mousedown always starts a new word.
                this.clearSelection(); 
                this.toggleCellSelection(e.target);
            }

            handleMouseOver(e) {
                if (!this.isDragging || !e.target.classList.contains('cell')) return;
                this.toggleCellSelection(e.target);
            }

            handleMouseUp() {
                if (!this.isDragging) return;
                this.isDragging = false;
                this.submitWord();
            }
            
            toggleCellSelection(cellEl) {
                if (this.selectedCells.includes(cellEl)) return; // Don't re-select
                this.selectedCells.push(cellEl);
                cellEl.classList.add('selected');
                this.sendSelectionUpdate();
            }

            clearSelection() {
                this.selectedCells.forEach(cell => cell.classList.remove('selected'));
                this.selectedCells = [];
                this.sendSelectionUpdate();
            }
            
            sendSelectionUpdate() {
                 conn.send({ type: 'selection_update', path: this.selectedCells.map(c => ({ r: c.dataset.r, c: c.dataset.c })) });
            }

            submitWord() {
                if (this.selectedCells.length === 0) return;

                const selectedWord = this.selectedCells.map(c => c.textContent).join('');
                this.validateAndScoreWord(selectedWord);
                this.validateAndScoreWord(selectedWord.split('').reverse().join(''));
                
                // Clear selection after submitting
                this.clearSelection();
            }

            validateAndScoreWord(word) {
                if (word.length < 3 || this.foundWords.has(word) || !FULL_DICTIONARY.has(word.toUpperCase())) {
                    return;
                }

                this.foundWords.add(word);
                let points = word.length;
                let isBonus = this.targetWords.has(word.toUpperCase());

                if (isBonus) {
                    points += 10; // Bonus points!
                    this.addBonusWord(word.toUpperCase());
                }

                this.updateScore(this.score + points);
                conn.send({ type: 'word_found', word: word.toUpperCase(), newScore: this.score, isBonus });
            }
            
            // --- OPPONENT ONLY METHODS ---
            updateOpponentSelection(path) {
                this.boardEl.querySelectorAll('.opponent-selecting').forEach(c => c.classList.remove('opponent-selecting'));
                path.forEach(pos => {
                    const cell = this.boardEl.querySelector(`[data-r='${pos.r}'][data-c='${pos.c}']`);
                    if (cell) cell.classList.add('opponent-selecting');
                });
            }
        }
        
        // --- WEBRTC LOGIC ---
        function initializePeer(host, roomName) {
            isHost = host;
            peer = isHost ? new Peer(roomName) : new Peer();

            peer.on('open', (id) => {
                if (!isHost) connectToHost(roomName);
                else mainStatusEl.textContent = `Room "${roomName}" created. Waiting...`;
            });

            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection();
            });
            peer.on('error', (err) => { mainStatusEl.textContent = `Error: ${err.message}`; });
        }

        function connectToHost(roomName) {
            conn = peer.connect(roomName);
            setupConnection();
        }

        function setupConnection() {
            conn.on('open', () => {
                connectionSetupEl.style.display = 'none';
                gameAreaEl.style.display = 'flex';
                newGameBtn.style.display = 'block';

                myPlayer = new Player(isHost ? 1 : 2, true);
                opponentPlayer = new Player(isHost ? 2 : 1, false);

                if (isHost) {
                    newGameBtn.disabled = false;
                    mainStatusEl.textContent = "Connected! Click 'New Game' to start.";
                } else {
                    newGameBtn.disabled = true;
                    mainStatusEl.textContent = "Connected! Waiting for host to start.";
                }
            });

            conn.on('data', (data) => {
                switch (data.type) {
                    case 'start_game':
                        startNewGame(data.targetWords, data.grid);
                        break;
                    case 'selection_update':
                        opponentPlayer.updateOpponentSelection(data.path);
                        break;
                    case 'word_found':
                        opponentPlayer.updateScore(data.newScore);
                        if (data.isBonus) {
                            opponentPlayer.addBonusWord(data.word);
                        }
                        break;
                }
            });
            
            conn.on('close', () => {
                mainStatusEl.textContent = "Opponent disconnected.";
                if(gameTimer) clearInterval(gameTimer);
            });
        }
        
        // --- GAME LOGIC ---
        function generateNewBoard() {
            const targetWords = [...TARGET_WORDS_POOL].sort(() => 0.5 - Math.random()).slice(0, 10);
            targetWords.sort((a,b) => b.length - a.length);

            let grid = Array(GRID_SIZE.rows).fill(null).map(() => Array(GRID_SIZE.cols).fill(''));
            
            for (const word of targetWords) {
                let placed = false;
                for (let i = 0; i < 200 && !placed; i++) {
                    const dir = Math.floor(Math.random() * 4);
                    const wordToPlace = word;
                    
                    let r, c, canPlace = true;

                    switch(dir) {
                        case 0: // horizontal
                           r = Math.floor(Math.random() * GRID_SIZE.rows);
                           c = Math.floor(Math.random() * (GRID_SIZE.cols - word.length + 1));
                           for (let j = 0; j < word.length; j++) if(grid[r][c+j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r][c+j] = wordToPlace[j];
                           break;
                        case 1: // vertical
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * GRID_SIZE.cols);
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c] = wordToPlace[j];
                           break;
                        case 2: // diagonal down-right
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * (GRID_SIZE.cols - word.length + 1));
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c+j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c+j] = wordToPlace[j];
                           break;
                        case 3: // diagonal down-left
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * (word.length -1));
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c-j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c-j] = wordToPlace[j];
                           break;
                    }
                    if(canPlace) placed = true;
                }
            }
            
            for (let r = 0; r < GRID_SIZE.rows; r++) {
                for (let c = 0; c < GRID_SIZE.cols; c++) {
                    if (grid[r][c] === '') {
                        grid[r][c] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(Math.random() * 26)];
                    }
                }
            }
            return { targetWords, grid };
        }

        function startNewGame(targetWords, grid) {
            mainStatusEl.textContent = 'Find as many words as you can!';
            [myPlayer, opponentPlayer].forEach(p => p.reset());
            myPlayer.setupBoard(targetWords, grid);
            opponentPlayer.setupBoard(targetWords, grid);
            
            let timeLeft = GAME_DURATION;
            if(gameTimer) clearInterval(gameTimer);
            timerDisplay.textContent = `Time: 2:00`;

            gameTimer = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerDisplay.textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;

                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }

        function endGame() {
            clearInterval(gameTimer);
            timerDisplay.textContent = "Time's Up!";
            myPlayer.boardEl.classList.add('disabled');
            
            let myResult, myText;
            if (myPlayer.score > opponentPlayer.score) { myResult = 'winner'; myText = 'WINNER!'; } 
            else if (myPlayer.score < opponentPlayer.score) { myResult = 'loser'; myText = 'SO CLOSE!'; } 
            else { myResult = 'draw'; myText = 'DRAW!'; }
            
            const myOverlay = document.createElement('div');
            myOverlay.className = `result-overlay ${myResult}`;
            myOverlay.textContent = myText;
            myPlayer.areaEl.appendChild(myOverlay);
            
            const opponentOverlay = document.createElement('div');
            opponentOverlay.className = `result-overlay ${myResult === 'winner' ? 'loser' : myResult === 'loser' ? 'winner' : 'draw'}`;
            opponentOverlay.textContent = `${myResult === 'winner' ? 'SO CLOSE!' : myResult === 'loser' ? 'WINNER!' : 'DRAW!'}`;
            opponentPlayer.areaEl.appendChild(opponentOverlay);
        }

        // --- EVENT LISTENERS ---
        createRoomBtn.addEventListener('click', () => {
            const roomName = roomNameInput.value.trim();
            if (!roomName) return alert('Please enter a room name.');
            initializePeer(true, roomName);
        });

        joinRoomBtn.addEventListener('click', () => {
            const roomName = roomNameInput.value.trim();
            if (!roomName) return alert('Please enter a room name to join.');
            initializePeer(false, roomName);
        });

        newGameBtn.addEventListener('click', () => {
            if (!isHost) return;
            const { targetWords, grid } = generateNewBoard();
            conn.send({ type: 'start_game', targetWords, grid });
            startNewGame(targetWords, grid);
        });
    </script>
</body>
</html>
