<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Discovery Battle</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --board-bg: #FFFFFF;
            --cell-border: #E0E0E0;
            --text-color: #333;
            --selected-bg: #4A90E2;
            --opponent-selected-bg: #FFB6C1;
            --bonus-word-color: #28a745;
            --winner-overlay: rgba(40, 167, 69, 0.8);
            --loser-overlay: rgba(220, 53, 69, 0.8);
            --draw-overlay: rgba(108, 117, 125, 0.8);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #F4F4F9;
            color: var(--text-color);
            margin: 0;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
        }

        #game-header { text-align: center; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        #main-status { font-size: 1.2rem; font-weight: 600; margin-bottom: 1rem; height: 25px; }
        
        #connection-setup { display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1rem; align-items: center; background-color: #fff; padding: 1.5rem; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .input-group { display: flex; gap: 0.5rem; width: 100%; justify-content: center; }
        #connection-setup input { padding: 0.75rem; border: 1px solid #ccc; border-radius: 8px; font-size: 1rem; }
        #connection-setup button { padding: 0.75rem 1rem; font-size: 1rem; font-weight: 600; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
        #create-room-btn { background-color: #28a745; }
        #join-room-btn { background-color: #007bff; }

        #game-area { display: none; flex-direction: column; align-items: center; width: 100%; }
        #game-info { display: flex; justify-content: space-around; width: 100%; max-width: 800px; margin-bottom: 1rem; font-size: 1.5rem; font-weight: bold; }
        #timer-display { color: #DC3545; }

        #game-container { display: flex; justify-content: center; gap: 2rem; width: 100%; max-width: 1200px; align-items: flex-start; }
        .player-area { flex: 1; display: flex; flex-direction: column; align-items: center; position: relative; }
        
        .result-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; color: white; display: flex; align-items: center; justify-content: center; font-size: 3rem; font-weight: bold; border-radius: 12px; z-index: 100; text-shadow: 2px 2px 4px #000; }
        .result-overlay.winner { background: var(--winner-overlay); }
        .result-overlay.loser { background: var(--loser-overlay); }
        .result-overlay.draw { background: var(--draw-overlay); }

        .board { display: grid; grid-template-columns: repeat(10, 1fr); gap: 4px; background-color: var(--board-bg); border: 2px solid var(--cell-border); border-radius: 12px; padding: 10px; aspect-ratio: 10 / 12; width: 100%; max-width: 500px; user-select: none; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .cell { display: flex; align-items: center; justify-content: center; font-size: 1.2rem; font-weight: bold; background-color: var(--board-bg); border-radius: 8px; cursor: pointer; transition: background-color 0.1s; aspect-ratio: 1 / 1; }
        .cell.selected { background-color: var(--selected-bg) !important; color: white; }
        .cell.opponent-selecting { background-color: var(--opponent-selected-bg) !important; }
        
        .score-display { font-size: 2.5rem; font-weight: bold; margin-top: 1rem; }
        
        .words-display-area { margin-top: 1rem; width: 100%; max-width: 400px; text-align: center; }
        .words-display-area h3 { margin-bottom: 0.5rem; }
        .found-words-list, .bonus-word-list { list-style: none; padding: 0.5rem; margin: 0; height: 100px; overflow-y: auto; background-color: #f0f0f0; border-radius: 8px; border: 1px solid #ddd; }
        .found-words-list li { color: #333; }
        .bonus-word-list li { font-weight: 600; color: var(--bonus-word-color); }

        #new-game-btn { margin-top: 1.5rem; padding: 0.8rem 1.5rem; font-size: 1rem; font-weight: 600; color: white; background-color: #6A5ACD; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; display: none; }
        #new-game-btn:disabled { background-color: #a9a1e4; cursor: not-allowed; }
    </style>
</head>
<body>

    <div id="game-header">
        <h1>Word Discovery Battle</h1>
        <div id="main-status">Enter your name to begin!</div>
    </div>

    <div id="connection-setup">
        <input type="text" id="player-name-input" placeholder="Your Name">
        <div class="input-group">
            <input type="text" id="room-name-input" placeholder="Room Name">
            <button id="create-room-btn">Create</button>
            <button id="join-room-btn">Join</button>
        </div>
    </div>

    <div id="game-area">
        <div id="game-info">
            <div id="timer-display">Time: 2:00</div>
        </div>
        <div id="game-container">
            <div class="player-area" id="player1-area">
                <h2 id="name-p1">You</h2>
                <div class="board" id="board-p1"></div>
                <div class="score-display" id="score-p1">Score: 0</div>
                <div class="words-display-area">
                    <h3>Your Found Words:</h3>
                    <ul class="found-words-list" id="found-words-p1"></ul>
                </div>
                <div class="words-display-area">
                    <h3>Bonus Words Found:</h3>
                    <ul class="bonus-word-list" id="bonus-words-p1"></ul>
                </div>
            </div>
            <div class="player-area" id="player2-area">
                <h2 id="name-p2">Opponent</h2>
                <div class="board" id="board-p2"></div>
                <div class="score-display" id="score-p2">Score: 0</div>
            </div>
        </div>
    </div>
    
    <button id="new-game-btn">New Game</button>

    <script>
        // NOTE: This dictionary is now massive to accept more words.
        const DICTIONARY_WORDS = [
            'a', 'aback', 'abacus', 'abandon', 'abandoned', 'abandonment', 'abashed', 'abate', 'abattoir', 'abbess', 'abbey', 'abbot', 'abbreviate', 'abbreviation', 'abdicate',
            'abdication', 'abdomen', 'abdominal', 'abduct', 'abduction', 'aberration', 'abet', 'abhor', 'abhorrence', 'abhorrent', 'abide', 'abiding', 'ability', 'abject',
            'abjure', 'ablaze', 'able', 'ably', 'abnormal', 'abnormality', 'abnormally', 'aboard', 'abode', 'abolish', 'abolition', 'abominable', 'abominate', 'abomination',
            'aboriginal', 'aborigine', 'abort', 'abortion', 'abortive', 'abound', 'about', 'above', 'abrasion', 'abrasive', 'abreast', 'abridge', 'abridgement', 'abroad',
            'abrupt', 'abruptly', 'abscess', 'abscond', 'absence', 'absent', 'absentee', 'absently', 'absolute', 'absolutely', 'absolution', 'absolve', 'absorb', 'absorbed',
            'absorbent', 'absorbing', 'absorption', 'abstain', 'abstemious', 'abstention', 'abstinence', 'abstract', 'absurd', 'absurdity', 'abundance', 'abundant', 'abuse',
            'abusive', 'abysmal', 'abyss', 'acacia', 'academic', 'academically', 'academy', 'accede', 'accelerate', 'acceleration', 'accelerator', 'accent', 'accentuate',
            'accept', 'acceptable', 'acceptably', 'acceptance', 'accepted', 'access', 'accessible', 'accession', 'accessory', 'accident', 'accidental', 'acclaim',
            'acclimatize', 'accolade', 'accommodate', 'accommodating', 'accommodation', 'accompaniment', 'accompany', 'accomplice', 'accomplish', 'accomplished',
            'accomplishment', 'accord', 'accordance', 'accordingly', 'accordion', 'accost', 'account', 'accountable', 'accountant', 'accrue', 'accumulate', 'accumulation',
            'accuracy', 'accurate', 'accurately', 'accursed', 'accusation', 'accuse', 'accused', 'accustom', 'accustomed', 'ace', 'acerbic', 'ache', 'achieve', 'achievement',
            'acid', 'acidity', 'acidly', 'acknowledge', 'acknowledgement', 'acme', 'acne', 'acorn', 'acoustic', 'acoustics', 'acquaint', 'acquaintance', 'acquainted',
            'acquiesce', 'acquiescence', 'acquire', 'acquisition', 'acquit', 'acquittal', 'acre', 'acrid', 'acrimonious', 'acrimony', 'acrobat', 'acrobatic', 'acrobatics',
            'acronym', 'across', 'act', 'acting', 'action', 'activate', 'active', 'actively', 'activist', 'activity', 'actor', 'actress', 'actual', 'actuality', 'actually',
            'acumen', 'acupuncture', 'acute', 'acutely', 'ad', 'adamant', 'adapt', 'adaptable', 'adaptation', 'adapter', 'add', 'addendum', 'adder', 'addict', 'addicted',
            'addiction', 'addictive', 'addition', 'additional', 'additionally', 'additive', 'address', 'addressee', 'adept', 'adequate', 'adequately', 'adhere', 'adherence',
            'adherent', 'adhesion', 'adhesive', 'adjacent', 'adjective', 'adjoin', 'adjourn', 'adjournment', 'adjudge', 'adjudicate', 'adjunct', 'adjust', 'adjustable',
            'adjustment', 'administer', 'administration', 'administrative', 'administrator', 'admirable', 'admirably', 'admiral', 'admiration', 'admire', 'admirer',
            'admiring', 'admissible', 'admission', 'admit', 'admittance', 'admittedly', 'admonish', 'admonition', 'ado', 'adobe', 'adolescence', 'adolescent', 'adopt',
            'adoption', 'adoptive', 'adorable', 'adoration', 'adore', 'adorn', 'adornment', 'adrift', 'adroit', 'adulation', 'adult', 'adulterate', 'adulterer', 'adulterous',
            'adultery', 'adulthood', 'advance', 'advanced', 'advancement', 'advantage', 'advantageous', 'advent', 'adventure', 'adventurous', 'adverb', 'adverbial',
            'adversary', 'adverse', 'adversity', 'advert', 'advertise', 'advertisement', 'advice', 'advisable', 'advise', 'adviser', 'advisor', 'advisory', 'advocacy',
            'advocate', 'aerial', 'aero', 'aerobatics', 'aerobics', 'aerodrome', 'aerodynamic', 'aerodynamics', 'aerogram', 'aeronautics', 'aeroplane', 'aerosol',
            'aerospace', 'aesthetics', 'afar', 'affable', 'affably', 'affair', 'affect', 'affectation', 'affected', 'affecting', 'affection', 'affectionate',
            'affectionately', 'affidavit', 'affiliate', 'affiliation', 'affinity', 'affirm', 'affirmation', 'affirmative', 'affix', 'afflict', 'affliction', 'affluence',
            'affluent', 'afford', 'affront', 'afield', 'afloat', 'afoot', 'aforementioned', 'afraid', 'afresh', 'after', 'aftermath', 'afternoon', 'aftershave',
            'afterthought', 'afterwards', 'again', 'against', 'age', 'aged', 'agency', 'agenda', 'agent', 'aggravate', 'aggravating', 'aggravation', 'aggregate', 'aggression',
            'aggressive', 'aggressively', 'aggressor', 'aggrieved', 'aghast', 'agile', 'agility', 'aging', 'agitate', 'agitated', 'agitation', 'agitator', 'agnostic', 'ago',
            'agonize', 'agonizing', 'agony', 'agree', 'agreeable', 'agreeably', 'agreed', 'agreement', 'agricultural', 'agriculture', 'aground', 'ahead', 'aid', 'aide', 'ail',
            'ailing', 'ailment', 'aim', 'aimless', 'air', 'airborne', 'air-conditioned', 'air-conditioner', 'air-conditioning', 'aircraft', 'airfield', 'air-force',
            'air-hostess', 'airless', 'airline', 'airliner', 'airlock', 'airmail', 'airplane', 'airport', 'airsick', 'airstrip', 'airtight', 'airway', 'airy', 'aisle',
        ];
        const FULL_DICTIONARY = new Set(DICTIONARY_WORDS.map(w => w.toUpperCase()));
        
        // --- NEW: Sound Effects ---
        const correctSound = new Audio('https://www.niilow.com/corect.mp3');
        const wrongSound = new Audio('https://www.niilow.com/wrong.mp3');
        
        const GRID_SIZE = { rows: 12, cols: 10 };
        const GAME_DURATION = 120; // 2 minutes in seconds

        let peer, conn, isHost, gameTimer;
        let myPlayer, opponentPlayer;

        // --- DOM ELEMENTS ---
        const mainStatusEl = document.getElementById('main-status');
        const connectionSetupEl = document.getElementById('connection-setup');
        const playerNameInput = document.getElementById('player-name-input');
        const roomNameInput = document.getElementById('room-name-input');
        const createRoomBtn = document.getElementById('create-room-btn');
        const joinRoomBtn = document.getElementById('join-room-btn');
        const gameAreaEl = document.getElementById('game-area');
        const newGameBtn = document.getElementById('new-game-btn');
        const timerDisplay = document.getElementById('timer-display');
        
        class Player {
            constructor(id, name, isLocal) {
                this.id = id;
                this.name = name;
                this.isLocal = isLocal;
                this.boardEl = document.getElementById(`board-p${id}`);
                this.scoreEl = document.getElementById(`score-p${id}`);
                this.nameEl = document.getElementById(`name-p${id}`);
                this.bonusWordListEl = this.isLocal ? document.getElementById(`bonus-words-p${id}`) : null;
                this.foundWordsListEl = this.isLocal ? document.getElementById(`found-words-p${id}`) : null;
                this.areaEl = document.getElementById(`player${id}-area`);
                
                this.nameEl.textContent = this.name;
                this.score = 0;
                this.foundWords = new Set();
                this.isDragging = false;
                this.selectedCells = [];

                if (isLocal) {
                    this.boardEl.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                    this.boardEl.addEventListener('mouseover', (e) => this.handleMouseOver(e));
                    document.addEventListener('mouseup', () => this.handleMouseUp());
                }
            }

            reset() {
                this.score = 0;
                this.foundWords.clear();
                if(this.bonusWordListEl) this.bonusWordListEl.innerHTML = '';
                if(this.foundWordsListEl) this.foundWordsListEl.innerHTML = '';
                this.boardEl.classList.remove('disabled');
                const overlay = this.areaEl.querySelector('.result-overlay');
                if (overlay) overlay.remove();
                this.updateScore(0);
            }

            setupBoard(targetWords, grid) {
                this.targetWords = new Set(targetWords);
                this.grid = grid;
                this.drawBoard();
            }
            
            drawBoard() {
                this.boardEl.innerHTML = '';
                for (let r = 0; r < GRID_SIZE.rows; r++) {
                    for (let c = 0; c < GRID_SIZE.cols; c++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.r = r;
                        cell.dataset.c = c;
                        cell.textContent = this.grid[r][c];
                        this.boardEl.appendChild(cell);
                    }
                }
            }
            
            updateScore(newScore) {
                this.score = newScore;
                this.scoreEl.textContent = `Score: ${this.score}`;
            }

            addBonusWord(word) {
                if (!this.bonusWordListEl) return;
                const li = document.createElement('li');
                li.textContent = word;
                this.bonusWordListEl.appendChild(li);
                this.bonusWordListEl.scrollTop = this.bonusWordListEl.scrollHeight;
            }

            addFoundWord(word) {
                if (!this.foundWordsListEl) return;
                const li = document.createElement('li');
                li.textContent = word;
                this.foundWordsListEl.appendChild(li);
                this.foundWordsListEl.scrollTop = this.foundWordsListEl.scrollHeight;
            }

            handleMouseDown(e) {
                if (gameTimer <= 0 || !e.target.classList.contains('cell')) return;
                this.isDragging = true;
                this.clearSelection(); 
                this.addCellToSelection(e.target);
            }

            handleMouseOver(e) {
                if (!this.isDragging || !e.target.classList.contains('cell')) return;
                this.addCellToSelection(e.target);
            }

            handleMouseUp() {
                if (!this.isDragging) return;
                this.isDragging = false;
                this.submitWord();
            }
            
            addCellToSelection(cellEl) {
                if (this.selectedCells.includes(cellEl)) return;
                this.selectedCells.push(cellEl);
                cellEl.classList.add('selected');
                this.sendSelectionUpdate();
            }

            clearSelection() {
                this.selectedCells.forEach(cell => cell.classList.remove('selected'));
                this.selectedCells = [];
                this.sendSelectionUpdate();
            }
            
            sendSelectionUpdate() {
                 conn.send({ type: 'selection_update', path: this.selectedCells.map(c => ({ r: c.dataset.r, c: c.dataset.c })) });
            }

            submitWord() {
                if (this.selectedCells.length === 0) return;
                const selectedWord = this.selectedCells.map(c => c.textContent).join('');
                
                let foundAnyValidWord = false;
                if (this.validateAndScoreWord(selectedWord)) foundAnyValidWord = true;
                if (this.validateAndScoreWord(selectedWord.split('').reverse().join(''))) foundAnyValidWord = true;
                
                if (foundAnyValidWord) {
                    correctSound.play();
                } else {
                    wrongSound.play();
                }
                
                this.clearSelection();
            }

            validateAndScoreWord(word) {
                const upperWord = word.toUpperCase();
                if (word.length < 3 || this.foundWords.has(upperWord) || !FULL_DICTIONARY.has(upperWord)) {
                    return false; // Word is not valid
                }

                this.foundWords.add(upperWord);
                this.addFoundWord(word);

                let points = word.length;
                let isBonus = this.targetWords.has(upperWord);

                if (isBonus) {
                    points += 10;
                    this.addBonusWord(upperWord);
                }

                this.updateScore(this.score + points);
                conn.send({ type: 'word_found', word: upperWord, newScore: this.score, isBonus });
                return true; // Word was valid and scored
            }
            
            updateOpponentSelection(path) {
                this.boardEl.querySelectorAll('.opponent-selecting').forEach(c => c.classList.remove('opponent-selecting'));
                path.forEach(pos => {
                    const cell = this.boardEl.querySelector(`[data-r='${pos.r}'][data-c='${pos.c}']`);
                    if (cell) cell.classList.add('opponent-selecting');
                });
            }
        }
        
        function initializePeer(host, roomName, playerName) {
            isHost = host;
            peer = isHost ? new Peer(roomName) : new Peer();

            peer.on('open', (id) => {
                if (!isHost) connectToHost(roomName, playerName);
                else mainStatusEl.textContent = `Room "${roomName}" created. Waiting...`;
            });

            peer.on('connection', (connection) => {
                conn = connection;
                setupConnection(playerName);
            });
            peer.on('error', (err) => { mainStatusEl.textContent = `Error: ${err.message}`; });
        }

        function connectToHost(roomName, playerName) {
            conn = peer.connect(roomName);
            setupConnection(playerName);
        }

        function setupConnection(myName) {
            conn.on('open', () => {
                conn.send({ type: 'name_sync', name: myName });
                
                connectionSetupEl.style.display = 'none';
                gameAreaEl.style.display = 'flex';
                newGameBtn.style.display = 'block';

                myPlayer = new Player(isHost ? 1 : 2, myName, true);
            });

            conn.on('data', (data) => {
                switch (data.type) {
                    case 'name_sync':
                        opponentPlayer = new Player(isHost ? 2 : 1, data.name, false);
                         if (isHost) {
                            newGameBtn.disabled = false;
                            mainStatusEl.textContent = `Connected to ${data.name}! Click 'New Game' to start.`;
                        } else {
                            newGameBtn.disabled = true;
                            mainStatusEl.textContent = `Connected to ${data.name}! Waiting for them to start.`;
                        }
                        break;
                    case 'start_game':
                        startNewGame(data.targetWords, data.grid);
                        break;
                    case 'selection_update':
                        if(opponentPlayer) opponentPlayer.updateOpponentSelection(data.path);
                        break;
                    case 'word_found':
                        if(opponentPlayer) {
                            opponentPlayer.updateScore(data.newScore);
                        }
                        break;
                }
            });
            
            conn.on('close', () => {
                mainStatusEl.textContent = "Opponent disconnected.";
                if(gameTimer) clearInterval(gameTimer);
            });
        }
        
        function generateNewBoard() {
             const targetWords = [...new Set(DICTIONARY_WORDS.filter(w=>w.length > 4 && w.length < 9))].sort(() => 0.5 - Math.random()).slice(0, 10);
            targetWords.sort((a,b) => b.length - a.length);

            let grid = Array(GRID_SIZE.rows).fill(null).map(() => Array(GRID_SIZE.cols).fill(''));
            
            for (const word of targetWords) {
                let placed = false;
                for (let i = 0; i < 200 && !placed; i++) {
                    const dir = Math.floor(Math.random() * 4);
                    const wordToPlace = word.toUpperCase();
                    
                    let r, c, canPlace = true;

                    switch(dir) {
                        case 0: // horizontal
                           r = Math.floor(Math.random() * GRID_SIZE.rows);
                           c = Math.floor(Math.random() * (GRID_SIZE.cols - word.length + 1));
                           for (let j = 0; j < word.length; j++) if(grid[r][c+j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r][c+j] = wordToPlace[j];
                           break;
                        case 1: // vertical
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * GRID_SIZE.cols);
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c] = wordToPlace[j];
                           break;
                        case 2: // diagonal down-right
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * (GRID_SIZE.cols - word.length + 1));
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c+j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c+j] = wordToPlace[j];
                           break;
                        case 3: // diagonal down-left
                           r = Math.floor(Math.random() * (GRID_SIZE.rows - word.length + 1));
                           c = Math.floor(Math.random() * (GRID_SIZE.cols - (word.length -1))) + (word.length-1);
                           for (let j = 0; j < word.length; j++) if(grid[r+j][c-j] !== '') canPlace = false;
                           if(canPlace) for (let j = 0; j < word.length; j++) grid[r+j][c-j] = wordToPlace[j];
                           break;
                    }
                    if(canPlace) placed = true;
                }
            }
            
            for (let r = 0; r < GRID_SIZE.rows; r++) {
                for (let c = 0; c < GRID_SIZE.cols; c++) {
                    if (grid[r][c] === '') {
                        grid[r][c] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(Math.random() * 26)];
                    }
                }
            }
            return { targetWords: targetWords.map(w=>w.toUpperCase()), grid };
        }

        function startNewGame(targetWords, grid) {
            mainStatusEl.textContent = 'Find as many words as you can!';
            if (myPlayer) myPlayer.reset();
            if (opponentPlayer) opponentPlayer.reset();
            
            myPlayer.setupBoard(targetWords, grid);
            opponentPlayer.setupBoard(targetWords, grid);
            
            let timeLeft = GAME_DURATION;
            if(gameTimer) clearInterval(gameTimer);
            timerDisplay.textContent = `Time: 2:00`;
            gameTimer = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                timerDisplay.textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                if (timeLeft <= 0) endGame();
            }, 1000);
        }

        function endGame() {
            clearInterval(gameTimer);
            timerDisplay.textContent = "Time's Up!";
            myPlayer.boardEl.classList.add('disabled');
            
            let myResult, myText;
            if (myPlayer.score > opponentPlayer.score) { myResult = 'winner'; myText = 'WINNER!'; } 
            else if (myPlayer.score < opponentPlayer.score) { myResult = 'loser'; myText = 'SO CLOSE!'; } 
            else { myResult = 'draw'; myText = 'DRAW!'; }
            
            const myOverlay = document.createElement('div');
            myOverlay.className = `result-overlay ${myResult}`;
            myOverlay.textContent = myText;
            myPlayer.areaEl.appendChild(myOverlay);
            
            const opponentOverlay = document.createElement('div');
            opponentOverlay.className = `result-overlay ${myResult === 'winner' ? 'loser' : myResult === 'loser' ? 'winner' : 'draw'}`;
            opponentOverlay.textContent = `${myResult === 'winner' ? 'SO CLOSE!' : myResult === 'loser' ? 'WINNER!' : 'DRAW!'}`;
            opponentPlayer.areaEl.appendChild(opponentOverlay);
        }

        function handleConnection(isHost) {
            const playerName = playerNameInput.value.trim();
            const roomName = roomNameInput.value.trim();
            if (!playerName) return alert('Please enter your name.');
            if (!roomName) return alert('Please enter a room name.');
            initializePeer(isHost, roomName, playerName);
        }

        createRoomBtn.addEventListener('click', () => handleConnection(true));
        joinRoomBtn.addEventListener('click', () => handleConnection(false));

        newGameBtn.addEventListener('click', () => {
            if (!isHost) return;
            const { targetWords, grid } = generateNewBoard();
            conn.send({ type: 'start_game', targetWords, grid });
            startNewGame(targetWords, grid);
        });
    </script>
</body>
</html>
